import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:geoflutterfire_plus/geoflutterfire_plus.dart';
import 'package:sevaexchange/components/calendar_events/models/kloudless_models.dart';
import 'package:sevaexchange/models/data_model.dart';
import 'package:sevaexchange/models/models.dart';

enum ProjectMode {
  timebankProject,
  memberProject,
}

extension ProjectModelLabel on ProjectMode {
  String get readable {
    switch (this) {
      case ProjectMode.timebankProject:
        return 'Timebank';
      case ProjectMode.memberProject:
        return 'Personal';
    }
  }
}

class ProjectModelList {
  final List<ProjectModel> events;
  final List<ProjectModel> completedEvents;

  ProjectModelList(this.events, this.completedEvents);
}

class ProjectModel extends DataModel {
  static const String? NO_MESSAGING_ROOM_CREATED = 'NOT_YET_CREATED';

  String? id;
  String? name;
  String? timebankId;
  String? communityId;
  String? description;
  String? emailId;
  String? phoneNumber;
  String? creatorId;
  String? address;
  String? photoUrl;
  String? cover_url;
  ProjectMode? mode;
  int? createdAt;
  int? startTime;
  int? endTime;
  GeoFirePoint? location;

  List<String>? members = [];
  List<String>? pendingRequests = [];
  List<String>? completedRequests = [];
  Map<String, dynamic>? associatedmembers = {};
  bool? requestedSoftDelete = false;
  bool? softDelete = false;
  bool? liveMode = true;
  String? associatedMessaginfRoomId;
  bool? public = false;
  bool? virtualProject = false;
  List<String>? timebanksPosted = [];
  String? communityName;
  String? registrationLink;
  bool? isRecurring = false;
  List<int>? recurringDays;
  int? occurenceCount = 1;
  End? end;
  bool autoGenerated = false;
  String? parentEventId;
  List<SponsorDataModel>? sponsors = [];
  EventMetaData? eventMetaData;

  ProjectModel({
    this.parentEventId,
    this.autoGenerated = false,
    this.isRecurring,
    this.recurringDays,
    this.occurenceCount,
    this.end,
    this.id,
    this.name,
    this.timebankId,
    this.communityId,
    this.description,
    this.emailId,
    this.phoneNumber,
    this.creatorId,
    this.address,
    this.photoUrl,
    this.cover_url,
    this.mode,
    this.createdAt,
    this.startTime,
    this.endTime,
    this.members,
    this.location,
    this.pendingRequests,
    this.completedRequests,
    this.softDelete,
    this.requestedSoftDelete,
    this.associatedMessaginfRoomId,
    this.associatedmembers,
    this.liveMode,
    this.public,
    this.virtualProject,
    this.timebanksPosted,
    this.communityName,
    this.registrationLink,
    this.sponsors,
    this.eventMetaData,
  });

  factory ProjectModel.fromMap(Map<String, dynamic> json) {
    GeoFirePoint? point;
    final geo = GeoFirePoint(GeoPoint(0, 0));

    if (json['location'] != null) {
      // Handle different location data formats
      if (json['location'] is Map<String, dynamic>) {
        if (json['location']['geopoint'] != null) {
          final geopoint = json['location']['geopoint'];
          if (geopoint is GeoPoint) {
            point = GeoFirePoint(GeoPoint(
              geopoint.latitude,
              geopoint.longitude,
            ));
          } else if (geopoint is Map<String, dynamic>) {
            final latitude = geopoint['_latitude'] ?? geopoint['latitude'];
            final longitude = geopoint['_longitude'] ?? geopoint['longitude'];

            if (latitude != null && longitude != null) {
              point = GeoFirePoint(GeoPoint(
                latitude is num ? latitude.toDouble() : 0.0,
                longitude is num ? longitude.toDouble() : 0.0,
              ));
            }
          }
        } else if (json['location']['geohash'] != null &&
            json['location']['geopoint'] == null) {
          // If we have a geohash but not a geopoint, try to extract coordinates from the data
          if (json['location']['coordinates'] != null) {
            final coordinates = json['location']['coordinates'];
            if (coordinates is Map<String, dynamic>) {
              final latitude =
                  coordinates['latitude'] ?? coordinates['_latitude'];
              final longitude =
                  coordinates['longitude'] ?? coordinates['_longitude'];

              if (latitude != null && longitude != null) {
                point = GeoFirePoint(GeoPoint(
                  latitude is num ? latitude.toDouble() : 0.0,
                  longitude is num ? longitude.toDouble() : 0.0,
                ));
              }
            } else if (coordinates is List && coordinates.length >= 2) {
              // Handle array format [longitude, latitude]
              point = GeoFirePoint(GeoPoint(
                coordinates[1] is num ? coordinates[1].toDouble() : 0.0,
                coordinates[0] is num ? coordinates[0].toDouble() : 0.0,
              ));
            }
          }
        }
      } else if (json['location'] is GeoPoint) {
        // Direct GeoPoint reference
        final geopoint = json['location'] as GeoPoint;
        point = GeoFirePoint(GeoPoint(
          geopoint.latitude,
          geopoint.longitude,
        ));
      }
    }

    return ProjectModel(
      eventMetaData: json.containsKey('eventMetaData')
          ? EventMetaData.fromMap(
              Map<String, dynamic>.from(json["eventMetaData"]))
          : null,
      isRecurring: json["isRecurring"] ?? false,
      recurringDays: json["recurringDays"] == null
          ? null
          : List.castFrom(json['recurringDays']),
      occurenceCount: json["occurenceCount"],
      end: json["end"] == null
          ? null
          : End.fromMap(Map<String, dynamic>.from(json['end'])),
      autoGenerated: json["autoGenerated"] ?? false,
      parentEventId: json["parentEventId"] ?? '',
      id: json["id"],
      name: json["name"],
      public: json['public'] ?? false,
      virtualProject: json['virtualProject'] ?? false,
      timebankId: json["timebank_id"],
      communityId: json["communityId"],
      description: json["description"],
      emailId: json["email_id"],
      phoneNumber: json["phone_number"],
      creatorId: json["creator_id"],
      address: json["address"],
      photoUrl: json["photo_url"],
      cover_url: json["cover_url"],
      registrationLink: json["registrationLink"],
      associatedMessaginfRoomId: json["associatedMessaginfRoomId"],
      mode: json["mode"] == null
          ? null
          : json["mode"] == 'Timebank'
              ? ProjectMode.timebankProject
              : ProjectMode.memberProject,
      createdAt: json["created_at"],
      startTime: json["start_time"],
      endTime: json["end_time"],
      softDelete: json["softDelete"] ?? false,
      liveMode: json["liveMode"] ?? true,
      requestedSoftDelete: json["requestedSoftDelete"] ?? false,
      location: point,
      members: List<String>.from(json["members"] ?? []),
      pendingRequests: List<String>.from(json["pendingRequests"] ?? []),
      completedRequests: List<String>.from(json["completedRequests"] ?? []),
      timebanksPosted: List<String>.from(json["timebanksPosted"] ?? []),
      associatedmembers:
          Map<String, dynamic>.from(json["associatedmembers"] ?? {}),
      communityName: json["communityName"],
      sponsors: json.containsKey("sponsors")
          ? List<SponsorDataModel>.from(
              json["sponsors"].map((x) => SponsorDataModel.fromMap(x)))
          : [],
    );
  }

  Map<String, dynamic> toMap() {
    final projectDetails = {
      "isRecurring": isRecurring ?? false,
      "recurringDays": recurringDays ?? [],
      "occurenceCount": occurenceCount ?? 0,
      "end": end?.toMap(),
      "autoGenerated": autoGenerated,
      "parentEventId": parentEventId,
      "id": id,
      "name": name,
      "timebank_id": timebankId,
      "communityId": communityId,
      "public": public ?? false,
      "virtualProject": virtualProject ?? false,
      "description": description,
      "email_id": emailId,
      "phone_number": phoneNumber,
      "creator_id": creatorId,
      "address": address,
      "photo_url": photoUrl,
      "cover_url": cover_url,
      "registrationLink": registrationLink,
      "mode": mode?.readable,
      "created_at": createdAt,
      "start_time": startTime,
      "end_time": endTime,
      "softDelete": softDelete ?? false,
      "liveMode": liveMode ?? true,
      "requestedSoftDelete": requestedSoftDelete ?? false,
      "members": members ?? [],
      "pendingRequests": pendingRequests ?? [],
      "completedRequests": completedRequests ?? [],
      "timebanksPosted": timebanksPosted ?? [],
      "associatedMessaginfRoomId": associatedMessaginfRoomId,
      "associatedmembers": associatedmembers ?? {},
      "communityName": communityName,
    };

    if (sponsors != null && sponsors!.isNotEmpty) {
      projectDetails['sponsors'] = sponsors!.map((x) => x.toMap()).toList();
    }

    if (eventMetaData != null) {
      projectDetails['eventMetaData'] = eventMetaData!.toMap();
    }

    if (location != null) {
      projectDetails['location'] = location!.data;
    }

    return projectDetails;
  }

  @override
  String toString() {
    return 'ProjectModel{id: $id, name: $name, registrationLink: $registrationLink, virtualProject: $virtualProject, communityName: $communityName, timebankId: $timebankId, communityId: $communityId, description: $description, emailId: $emailId, phoneNumber: $phoneNumber, liveMode: $liveMode, creatorId: $creatorId, address: $address, photoUrl: $photoUrl, cover_url: $cover_url, mode: $mode, createdAt: $createdAt, startTime: $startTime, endTime: $endTime, location: $location, members: $members, pendingRequests: $pendingRequests, completedRequests: $completedRequests, associatedmembers: $associatedmembers, requestedSoftDelete: $requestedSoftDelete, softDelete: $softDelete, associatedMessaginfRoomId: $associatedMessaginfRoomId, public: $public, timebanksPosted: $timebanksPosted}';
  }
}
