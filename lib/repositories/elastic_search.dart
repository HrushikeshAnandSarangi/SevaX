import 'dart:convert';

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:http/http.dart' as http;
import 'package:sevaexchange/flavor_config.dart';
import 'package:sevaexchange/l10n/l10n.dart';
import 'package:sevaexchange/models/category_model.dart';
import 'package:sevaexchange/models/community_category_model.dart';
import 'package:sevaexchange/models/offer_model.dart';
import 'package:sevaexchange/models/request_model.dart';
import 'package:sevaexchange/models/user_model.dart';
import 'package:sevaexchange/new_baseline/models/community_model.dart';
import 'package:sevaexchange/new_baseline/models/project_model.dart';
import 'package:sevaexchange/ui/utils/location_helper.dart';
import 'package:sevaexchange/utils/app_config.dart';
import 'package:sevaexchange/utils/search_via_zipcode.dart';

/// ElasticSearchApi class with web-friendly implementations
class ElasticSearchApi {
  static final String _url = FlavorConfig.values.elasticSearchBaseURL;
  static const int _requestTimeoutSeconds = 10;

  /// Make elastic search POST request with web-compatible error handling
  static Future<List<Map<String, dynamic>>> _makeElasticSearchPostRequest(
      String url, dynamic body) async {
    try {
      final response = await http.post(
        Uri.parse(_url + url),
        body: body,
        headers: {
          'authorization': 'basic dXNlcjpDaU4zNlVOaXhKeXE=',
          "Accept": "application/json",
          "Content-Type": "application/json"
        },
      ).timeout(Duration(seconds: _requestTimeoutSeconds));

      if (response.statusCode != 200) {
        throw Exception('Failed to load data: ${response.statusCode}');
      }

      final Map<String, dynamic> bodyMap = json.decode(response.body);
      final Map<String, dynamic> hitMap = bodyMap['hits'] ?? {};
      final List<dynamic> hitsDynamic = hitMap['hits'] ?? [];

      // Safely convert to the expected type
      final List<Map<String, dynamic>> hitList =
          hitsDynamic.map((item) => item as Map<String, dynamic>).toList();

      return hitList;
    } catch (e) {
      debugPrint('ElasticSearch request failed: $e');
      // Log error in a web-compatible way
      _logError('ElasticSearch request failed: $e');
      return [];
    }
  }

  /// Web-compatible logging function
  static void _logError(String message) {
    // Safely log errors without platform-specific dependencies
    try {
      debugPrint(message);
      // Only use console logging in web
      if (kIsWeb) {
        // Use dart:js interop safely or just log to console
        debugPrint('[Web] $message');
      }
    } catch (_) {
      // Fallback if logging fails
    }
  }

  /// Search public requests with better error handling
  static Future<List<RequestModel>> searchPublicRequests({
    required String queryString,
    UserModel? user,
    DistanceFilterData? distanceFilterData,
  }) async {
    final String endPoint = '//elasticsearch/requests/request/_search';
    try {
      debugPrint('hitting $endPoint');

      final dynamic body = json.encode(
        {
          "size": 3000,
          "query": {
            "bool": {
              "must": [
                {
                  "term": {
                    "public": true,
                  },
                },
                {
                  "term": {"accepted": false}
                },
                {
                  "term": {
                    "softDelete": false,
                  },
                },
                {
                  "term": {
                    "autoGenerated": false,
                  },
                },
                {
                  "multi_match": {
                    "query": queryString,
                    "fields": ["description", "email", "fullname", "title"],
                    "type": "phrase_prefix"
                  }
                }
              ]
            }
          }
        },
      );

      final List<Map<String, dynamic>> hitList =
          await _makeElasticSearchPostRequest(endPoint, body);

      final List<RequestModel> requestsList = [];

      for (final map in hitList) {
        final Map<String, dynamic> sourceMap = map['_source'] ?? {};
        final RequestModel model = RequestModel.fromMapElasticSearch(sourceMap);

        // Check for null location
        if (model.location == null ||
            distanceFilterData?.isInRadius(model.location!) == true) {
          final bool isTestEnvironment =
              AppConfig.isTestCommunity != null && AppConfig.isTestCommunity;

          if (isTestEnvironment) {
            if (model.liveMode == false) requestsList.add(model);
          } else {
            requestsList.add(model);
          }
        }
      }

      return requestsList;
    } catch (e) {
      debugPrint('Error searching public requests: $e');
      return Future.error("Error searching public requests: $e");
    }
  }

  /// Search public events with better error handling
  static Future<List<ProjectModel>> searchPublicEvents({
    required String queryString,
    UserModel? user,
    DistanceFilterData? distanceFilterData,
  }) async {
    final String endPoint = '//elasticsearch/sevaxprojects/_doc/_search';

    try {
      final dynamic body = json.encode(
        {
          "sort": {
            "start_time": {"order": "desc"}
          },
          "size": 3000,
          "query": {
            "bool": {
              "must": [
                {
                  "term": {
                    "public": true,
                  },
                },
                {
                  "term": {
                    "softDelete": false,
                  },
                },
                {
                  "multi_match": {
                    "query": queryString,
                    "fields": ["address", "description", "email_id", "name"],
                    "type": "phrase_prefix"
                  }
                }
              ]
            }
          }
        },
      );

      final List<Map<String, dynamic>> hitList =
          await _makeElasticSearchPostRequest(endPoint, body);

      final List<ProjectModel> projectsList = [];

      for (final map in hitList) {
        final Map<String, dynamic> sourceMap = map['_source'] ?? {};
        final ProjectModel model = ProjectModel.fromMap(sourceMap);

        // Check for null location
        if (model.location == null ||
            distanceFilterData?.isInRadius(model.location!) == true) {
          try {
            final bool isTestEnvironment =
                AppConfig.isTestCommunity != null && AppConfig.isTestCommunity;

            if (isTestEnvironment) {
              if (model.liveMode == false) projectsList.add(model);
            } else {
              projectsList.add(model);
            }
          } catch (e) {
            debugPrint('Error processing project: $e');
          }
        }
      }

      projectsList.sort((a, b) => (a.name ?? '').compareTo(b.name ?? ''));
      return projectsList;
    } catch (e) {
      debugPrint('Error searching public events: $e');
      return Future.error("Error searching public events: $e");
    }
  }

  /// Search public offers with better error handling
  static Future<List<OfferModel>> searchPublicOffers({
    required String queryString,
    UserModel? user,
    DistanceFilterData? distanceFilterData,
  }) async {
    final String endPoint = '//elasticsearch/offers/_doc/_search';

    try {
      final dynamic body = json.encode({
        "size": 3000,
        "query": {
          "bool": {
            "must": [
              {
                "term": {
                  "softDelete": false,
                },
              },
              {
                "term": {
                  "autoGenerated": false,
                },
              },
              {
                "term": {
                  "public": true,
                },
              },
              {
                "bool": {
                  "should": [
                    {
                      "nested": {
                        "path": "individualOfferDataModel",
                        "query": {
                          "bool": {
                            "should": {
                              "multi_match": {
                                "query": queryString,
                                "fields": [
                                  "individualOfferDataModel.description",
                                  "individualOfferDataModel.title"
                                ],
                                "type": "phrase_prefix"
                              }
                            }
                          }
                        }
                      }
                    },
                    {
                      "nested": {
                        "path": "groupOfferDataModel",
                        "query": {
                          "bool": {
                            "should": {
                              "multi_match": {
                                "query": queryString,
                                "fields": [
                                  "groupOfferDataModel.classDescription",
                                  "groupOfferDataModel.classTitle"
                                ],
                                "type": "phrase_prefix"
                              }
                            }
                          }
                        }
                      }
                    },
                    {
                      "multi_match": {
                        "query": queryString,
                        "fields": ["email", "fullname", "selectedAdrress"],
                        "type": "phrase_prefix"
                      }
                    }
                  ]
                }
              }
            ]
          }
        }
      });

      final List<Map<String, dynamic>> hitList =
          await _makeElasticSearchPostRequest(endPoint, body);

      final List<OfferModel> offersList = [];

      for (final map in hitList) {
        final Map<String, dynamic> sourceMap = map['_source'] ?? {};
        final OfferModel model = OfferModel.fromMapElasticSearch(sourceMap);

        // Check for null location
        if (model.location == null ||
            distanceFilterData?.isInRadius(model.location!) == true) {
          try {
            final bool isTestEnvironment =
                AppConfig.isTestCommunity != null && AppConfig.isTestCommunity;

            if (isTestEnvironment) {
              if (model.liveMode == false) offersList.add(model);
            } else {
              offersList.add(model);
            }
          } catch (e) {
            debugPrint('Error processing offer: $e');
          }
        }
      }

      return offersList;
    } catch (e) {
      debugPrint('Error searching public offers: $e');
      return Future.error("Error searching public offers: $e");
    }
  }

  /// Search communities with better error handling
  static Future<List<CommunityModel>> searchCommunity({
    required String queryString,
    required bool isSignedIn,
    DistanceFilterData? distanceFilterData,
  }) async {
    final Map<String, CommunityModel> communityList = {};

    try {
      if (isSignedIn) {
        try {
          final List<CommunityModel> communityListTemp =
              await SearchCommunityViaZIPCode.getCommunitiesViaZIPCode(
                  queryString);

          debugPrint(
              "Found ${communityListTemp.length} communities via ZIP code");

          for (final item in communityListTemp) {
            communityList[item.id] = item;
          }
        } catch (e) {
          debugPrint("No nearby communities found via ZIP: $e");
        }
      }

      final String endPoint = '//elasticsearch/sevaxcommunities/_doc/_search';
      final dynamic body = json.encode({
        "query": {
          "bool": {
            "must": [
              {
                "term": {
                  "softDelete": false,
                }
              },
              {
                "term": {
                  "private": false,
                }
              },
              {
                "multi_match": {
                  "query": queryString,
                  "fields": [
                    "name",
                    "billing_address.country",
                    "billing_address.city",
                    "billing_address.state",
                    "billing_address.pincode",
                  ],
                  "type": "phrase_prefix"
                }
              }
            ]
          }
        },
        "sort": {
          "created_at.keyword": {"order": "desc"}
        },
      });

      final List<Map<String, dynamic>> hitList =
          await _makeElasticSearchPostRequest(endPoint, body);

      for (final map in hitList) {
        try {
          final Map<String, dynamic> sourceMap = map['_source'] ?? {};
          final CommunityModel model = CommunityModel(sourceMap);

          final bool isInRadius =
              distanceFilterData?.isInRadius(model.location) ?? true;
          final bool isTestEnvironment =
              AppConfig.isTestCommunity != null && AppConfig.isTestCommunity;

          if (isInRadius) {
            if (isTestEnvironment) {
              if (model.testCommunity) communityList[model.id] = model;
            } else {
              communityList[model.id] = model;
            }
          }
        } catch (e) {
          debugPrint('Error processing community: $e');
        }
      }

      final List<CommunityModel> communities = communityList.values.toList();
      communities.sort((a, b) => a.name.compareTo(b.name));

      return communities;
    } catch (e) {
      debugPrint('Error searching communities: $e');
      return Future.error("Error searching communities: $e");
    }
  }

  /// Get public offers with better error handling
  static Future<List<OfferModel>> getPublicOffers({
    DistanceFilterData? distanceFilterData,
  }) async {
    final String endPoint = '//elasticsearch/offers/_doc/_search?size=1000';

    try {
      final bool isTestEnvironment =
          AppConfig.isTestCommunity != null && AppConfig.isTestCommunity;

      final dynamic body = json.encode({
        "query": {
          "bool": {
            "must": [
              {
                "term": {"liveMode": isTestEnvironment ? false : true}
              },
              {
                "term": {"public": true}
              },
              {
                "term": {"softDelete": false}
              },
              {
                "term": {"autoGenerated": false}
              }
            ]
          }
        }
      });

      final List<Map<String, dynamic>> hitList =
          await _makeElasticSearchPostRequest(endPoint, body);

      final List<OfferModel> models = [];

      for (final map in hitList) {
        final Map<String, dynamic> sourceMap = map['_source'] ?? {};
        final OfferModel model = OfferModel.fromMap(sourceMap);

        if (model.location == null ||
            distanceFilterData?.isInRadius(model.location!) == true) {
          if (isTestEnvironment) {
            if (model.liveMode == false) models.add(model);
          } else {
            models.add(model);
          }
        }
      }

      models.sort((a, b) => (a.fullName ?? '').compareTo(b.fullName ?? ''));
      return models;
    } catch (e) {
      debugPrint('Error getting public offers: $e');
      return Future.error("Error getting public offers: $e");
    }
  }

  /// Get public communities with better error handling
  static Future<List<CommunityModel>> getPublicCommunities({
    DistanceFilterData? distanceFilterData,
  }) async {
    final String endPoint =
        '//elasticsearch/sevaxcommunities/_doc/_search?size=1000';

    try {
      final bool isTestEnvironment =
          AppConfig.isTestCommunity != null && AppConfig.isTestCommunity;

      final dynamic body = json.encode({
        "query": {
          "bool": {
            "must": [
              {
                "term": {"private": false}
              },
              {
                "term": {"softDelete": false}
              },
              {
                "term": {"testCommunity": isTestEnvironment ? true : false}
              },
            ]
          }
        }
      });

      final List<Map<String, dynamic>> hitList =
          await _makeElasticSearchPostRequest(endPoint, body);

      final List<CommunityModel> models = [];

      for (final map in hitList) {
        final Map<String, dynamic> sourceMap = map['_source'] ?? {};
        final CommunityModel model = CommunityModel(sourceMap);

        if (distanceFilterData?.isInRadius(model.location) ?? true) {
          if (isTestEnvironment) {
            if (model.testCommunity) models.add(model);
          } else {
            models.add(model);
          }
        }
      }

      return models;
    } catch (e) {
      debugPrint('Error getting public communities: $e');
      return Future.error("Error getting public communities: $e");
    }
  }

  /// Get public requests with better error handling
  static Future<List<RequestModel>> getPublicRequests({
    DistanceFilterData? distanceFilterData,
  }) async {
    final String endPoint =
        '//elasticsearch/requests/request/_search?size=1000';

    try {
      final bool isTestEnvironment =
          AppConfig.isTestCommunity != null && AppConfig.isTestCommunity;

      final dynamic body = json.encode(
        {
          "query": {
            "bool": {
              "must": [
                {
                  "term": {"liveMode": isTestEnvironment ? false : true}
                },
                {
                  "term": {"public": true}
                },
                {
                  "term": {"softDelete": false}
                },
                {
                  "term": {"autoGenerated": false}
                },
                {
                  "term": {"accepted": false}
                },
              ]
            }
          },
          "sort": {
            "posttimestamp": {"order": "desc"}
          }
        },
      );

      final List<Map<String, dynamic>> hitList =
          await _makeElasticSearchPostRequest(endPoint, body);

      final List<RequestModel> models = [];

      for (final map in hitList) {
        final Map<String, dynamic> sourceMap = map['_source'] ?? {};
        final RequestModel model = RequestModel.fromMap(sourceMap);

        if (model.location == null ||
            distanceFilterData?.isInRadius(model.location!) == true) {
          if (!(model.accepted ?? false)) {
            if (isTestEnvironment) {
              if (model.liveMode == false) models.add(model);
            } else {
              models.add(model);
            }
          }
        }
      }

      return models;
    } catch (e) {
      debugPrint('Error getting public requests: $e');
      return Future.error("Error getting public requests: $e");
    }
  }

  /// Get all categories with better error handling
  static Future<List<CategoryModel>> getAllCategories(
      BuildContext context) async {
    try {
      final String key = S.of(context).localeName;
      final String endPoint =
          '//elasticsearch/request_categories/_doc/_search?size=200';

      final dynamic body = json.encode({
        "query": {"match_all": {}},
        "sort": {
          "title_en.keyword": {"order": "asc"}
        }
      });

      final List<Map<String, dynamic>> hitList =
          await _makeElasticSearchPostRequest(endPoint, body);

      final List<CategoryModel> categoryList = [];

      for (final map in hitList) {
        final Map<String, dynamic> sourceMap = map['_source'] ?? {};
        final String fieldKey = "title_${key ?? 'en'}";

        if (sourceMap[fieldKey] != null) {
          final CategoryModel model = CategoryModel.fromMap(sourceMap);
          categoryList.add(model);
        }
      }

      return categoryList;
    } catch (e) {
      debugPrint('Error getting all categories: $e');
      return Future.error("Error getting all categories: $e");
    }
  }

  /// Get all community categories with better error handling
  static Future<List<CommunityCategoryModel>>
      getAllCommunityCategories() async {
    try {
      final String endPoint =
          '//elasticsearch/community_categories/_doc/_search?size=200';

      final dynamic body = json.encode({
        "query": {"match_all": {}},
        "sort": {
          "en.keyword": {"order": "asc"}
        }
      });

      final List<Map<String, dynamic>> hitList =
          await _makeElasticSearchPostRequest(endPoint, body);

      final List<CommunityCategoryModel> categoryList = [];

      for (final map in hitList) {
        final Map<String, dynamic> sourceMap = map['_source'] ?? {};
        final CommunityCategoryModel model =
            CommunityCategoryModel.fromMap(sourceMap);
        categoryList.add(model);
      }

      return categoryList;
    } catch (e) {
      debugPrint('Error getting all community categories: $e');
      return Future.error("Error getting all community categories: $e");
    }
  }

  /// Get requests by category with better error handling
  static Future<List<RequestModel>> getRequestsByCategory(String typeId) async {
    try {
      final String endPoint = '//elasticsearch/requests/request/_search';
      final bool isTestEnvironment =
          AppConfig.isTestCommunity != null && AppConfig.isTestCommunity;

      final dynamic body = json.encode(
        {
          "query": {
            "bool": {
              "must": [
                {
                  "term": {"liveMode": isTestEnvironment ? false : true}
                },
                {
                  "term": {"public": true}
                },
                {
                  "term": {"accepted": false}
                },
                {
                  "term": {"softDelete": false}
                },
                {
                  "match": {"categories": typeId}
                },
              ]
            }
          },
          "sort": {
            "posttimestamp": {"order": "desc"}
          }
        },
      );

      final List<Map<String, dynamic>> hitList =
          await _makeElasticSearchPostRequest(endPoint, body);

      final List<RequestModel> models = [];

      for (final map in hitList) {
        final Map<String, dynamic> sourceMap = map['_source'] ?? {};
        final RequestModel model = RequestModel.fromMap(sourceMap);

        if (!(model.accepted ?? false)) {
          models.add(model);
        }
      }

      return models;
    } catch (e) {
      debugPrint('Error getting requests by category: $e');
      return Future.error("Error getting requests by category: $e");
    }
  }

  /// Get public projects with better error handling
  static Future<List<ProjectModel>> getPublicProjects({
    DistanceFilterData? distanceFilterData,
    String? sevaUserID,
    bool? showCompletedEvent,
  }) async {
    try {
      final String endPoint =
          '//elasticsearch/sevaxprojects/_doc/_search?size=1000';
      final bool isTestEnvironment =
          AppConfig.isTestCommunity != null && AppConfig.isTestCommunity;

      final dynamic body = json.encode({
        "sort": {
          "start_time": {"order": "desc"}
        },
        "query": {
          "bool": {
            "must": [
              {
                "term": {"liveMode": isTestEnvironment ? false : true}
              },
              {
                "term": {"public": true}
              },
              {
                "term": {"softDelete": false}
              },
              {
                "term": {"autoGenerated": false}
              }
            ]
          }
        }
      });

      final List<Map<String, dynamic>> hitList =
          await _makeElasticSearchPostRequest(endPoint, body);

      final List<ProjectModel> models = [];

      for (final map in hitList) {
        final Map<String, dynamic> sourceMap = map['_source'] ?? {};
        final ProjectModel model = ProjectModel.fromMap(sourceMap);

        // Safely get end time with null handling
        final int endTimeMillis = model.endTime ?? 0;
        final DateTime endDate =
            DateTime.fromMillisecondsSinceEpoch(endTimeMillis);

        if (model.location == null ||
            distanceFilterData?.isInRadius(model.location!) == true) {
          // Handle completed events
          if (showCompletedEvent == true) {
            if (endDate.isAfter(DateTime.now().subtract(Duration(days: 365))) &&
                endDate.isBefore(DateTime.now())) {
              _addProjectIfApplicable(model, isTestEnvironment, models);
            }
          } else {
            if (endDate.isBefore(DateTime.now())) {
              // For past events, only add if user is involved
              if ((sevaUserID != null && sevaUserID.isNotEmpty) &&
                  (model.creatorId == sevaUserID ||
                      (model.members != null &&
                          model.members!.contains(sevaUserID)) ||
                      model.associatedmembers?.containsKey(sevaUserID) ==
                          true)) {
                _addProjectIfApplicable(model, isTestEnvironment, models);
              }
            } else {
              // For future events, add all
              _addProjectIfApplicable(model, isTestEnvironment, models);
            }
          }
        }
      }

      return models;
    } catch (e) {
      debugPrint('Error getting public projects: $e');
      return Future.error("Error getting public projects: $e");
    }
  }

  /// Helper method to add project to list
  static void _addProjectIfApplicable(
      ProjectModel model, bool isTestEnvironment, List<ProjectModel> models) {
    if (isTestEnvironment) {
      if (model.liveMode == false) models.add(model);
    } else {
      models.add(model);
    }
  }

  /// Get communities by category with better error handling
  static Future<List<CommunityModel>> getCommunitiesByCategory(
      String communityCategoryId) async {
    try {
      final String endPoint =
          '//elasticsearch/sevaxcommunities/_doc/_search?size=1000';

      final dynamic body = json.encode({
        "sort": {
          "created_at.keyword": {"order": "desc"}
        },
        "query": {
          "bool": {
            "must": [
              {
                "query_string": {
                  "default_field": "communityCategories",
                  "query": communityCategoryId
                }
              },
              {
                "term": {"private": false}
              },
              {
                "term": {"softDelete": false}
              }
            ]
          }
        }
      });

      final List<Map<String, dynamic>> hitList =
          await _makeElasticSearchPostRequest(endPoint, body);

      final List<CommunityModel> models = [];

      for (final map in hitList) {
        final Map<String, dynamic> sourceMap = map['_source'] ?? {};
        final CommunityModel model = CommunityModel(sourceMap);
        models.add(model);
      }

      return models;
    } catch (e) {
      debugPrint('Error getting communities by category: $e');
      return Future.error("Error getting communities by category: $e");
    }
  }

  /// Get featured communities with better error handling
  static Future<List<CommunityModel>> getFeaturedCommunities() async {
    try {
      final String endPoint =
          '//elasticsearch/sevaxcommunities/_doc/_search?size=10';
      final bool isTestEnvironment =
          AppConfig.isTestCommunity != null && AppConfig.isTestCommunity;

      final dynamic body = json.encode({
        "query": {
          "bool": {
            "must": [
              {
                "term": {"testCommunity": isTestEnvironment ? true : false}
              },
              {
                "term": {"private": false}
              },
              {
                "term": {"softDelete": false}
              }
            ]
          }
        },
        "sort": {
          "featuredCommunity": {"order": "desc"}
        }
      });

      final List<Map<String, dynamic>> hitList =
          await _makeElasticSearchPostRequest(endPoint, body);

      final List<CommunityModel> models = [];

      for (final map in hitList) {
        final Map<String, dynamic> sourceMap = map['_source'] ?? {};
        final CommunityModel model = CommunityModel(sourceMap);
        models.add(model);
      }

      return models;
    } catch (e) {
      debugPrint('Error getting featured communities: $e');
      return Future.error("Error getting featured communities: $e");
    }
  }
}
