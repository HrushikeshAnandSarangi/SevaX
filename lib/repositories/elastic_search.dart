import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:http/http.dart' as http;
import 'package:sevaexchange/flavor_config.dart';
import 'package:sevaexchange/models/offer_model.dart';
import 'package:sevaexchange/models/request_model.dart';
import 'package:sevaexchange/models/user_model.dart';
import 'package:sevaexchange/new_baseline/models/community_model.dart';
import 'package:sevaexchange/new_baseline/models/project_model.dart';
import 'package:sevaexchange/utils/log_printer/log_printer.dart';
import 'package:sevaexchange/utils/utils.dart';

class ElasticSearchApi {
  static final _url = FlavorConfig.values.elasticSearchBaseURL;
  static Future<List<Map<String, dynamic>>> _makeElasticSearchPostRequest(
      String url, dynamic body) async {
    http.Response response = await http.post(
      _url + url,
      body: body,
      headers: {
        'authorization': 'basic dXNlcjpDaU4zNlVOaXhKeXE=',
        "Accept": "application/json",
        "Content-Type": "application/json"
      },
    );

    logger.i(response.body);

    Map<String, dynamic> bodyMap = json.decode(response.body);
    Map<String, dynamic> hitMap = bodyMap['hits'];
    List<Map<String, dynamic>> hitList = List.castFrom(hitMap['hits']);
    return hitList;
  }

  static Future<List<RequestModel>> searchPublicRequests({
    @required String queryString,
    UserModel user,
  }) async {
    String endPoint = '//elasticsearch/requests/request/_search';
    logger.d('hitting', endPoint);
    dynamic body = json.encode(
      {
        "size": 3000,
        "query": {
          "bool": {
            "must": [
              {
                "term": {
                  "public": true,
                },
              },
              {
                "term": {
                  "softDelete": false,
                },
              },
              {
                "term": {
                  "autoGenerated": false,
                },
              },
              {
                "multi_match": {
                  "query": queryString,
                  "fields": ["description", "email", "fullname", "title"],
                  "type": "phrase_prefix"
                }
              }
            ]
          }
        }
      },
    );
    List<Map<String, dynamic>> hitList =
        await _makeElasticSearchPostRequest(endPoint, body);
    List<RequestModel> requestsList = [];
    hitList.forEach((map) {
      Map<String, dynamic> sourceMap = map['_source'];

      if (!(user != null && isMemberBlocked(user, sourceMap["sevauserid"]))) {
        try {
          requestsList.add(RequestModel.fromMapElasticSearch(sourceMap));
        } on Exception catch (e) {
          logger.e(e);
        }
      }
    });
    return requestsList;
  }

  static Future<List<ProjectModel>> searchPublicEvents({
    @required String queryString,
    UserModel user,
  }) async {
    String endPoint = '//elasticsearch/sevaxprojects/_doc/_search';
    dynamic body = json.encode(
      {
        "size": 3000,
        "query": {
          "bool": {
            "must": [
              {
                "term": {
                  "public": true,
                },
              },
              {
                "term": {
                  "softDelete": false,
                },
              },
              {
                "multi_match": {
                  "query": queryString,
                  "fields": ["address", "description", "email_id", "name"],
                  "type": "phrase_prefix"
                }
              }
            ]
          }
        }
      },
    );
    List<Map<String, dynamic>> hitList =
        await _makeElasticSearchPostRequest(endPoint, body);
    List<ProjectModel> projectsList = [];
    hitList.forEach((map) {
      Map<String, dynamic> sourceMap = map['_source'];
      if (!(user != null && isMemberBlocked(user, sourceMap["creator_id"]))) {
        try {
          projectsList.add(ProjectModel.fromMap(sourceMap));
        } on Exception catch (e) {
          logger.e(e);
        }
      }
    });
    projectsList.sort((a, b) => a.name.compareTo(b.name));
    return projectsList;
  }

  static Future<List<OfferModel>> searchPublicOffers({
    @required queryString,
    UserModel user,
  }) async {
    String endPoint = '//elasticsearch/offers/_doc/_search';

    dynamic body = json.encode({
      "size": 3000,
      "query": {
        "bool": {
          "must": [
            {
              "term": {
                "softDelete": false,
              },
            },
            {
              "term": {
                "autoGenerated": false,
              },
            },
            {
              "term": {
                "public": true,
              },
            },
            {
              "bool": {
                "should": [
                  {
                    "nested": {
                      "path": "individualOfferDataModel",
                      "query": {
                        "bool": {
                          "should": {
                            "multi_match": {
                              "query": queryString,
                              "fields": [
                                "individualOfferDataModel.description",
                                "individualOfferDataModel.title"
                              ],
                              "type": "phrase_prefix"
                            }
                          }
                        }
                      }
                    }
                  },
                  {
                    "nested": {
                      "path": "groupOfferDataModel",
                      "query": {
                        "bool": {
                          "should": {
                            "multi_match": {
                              "query": queryString,
                              "fields": [
                                "groupOfferDataModel.classDescription",
                                "groupOfferDataModel.classTitle"
                              ],
                              "type": "phrase_prefix"
                            }
                          }
                        }
                      }
                    }
                  },
                  {
                    "multi_match": {
                      "query": queryString,
                      "fields": ["email", "fullname", "selectedAdrress"],
                      "type": "phrase_prefix"
                    }
                  }
                ]
              }
            }
          ]
        }
      }
    });

    List<Map<String, dynamic>> hitList =
        await _makeElasticSearchPostRequest(endPoint, body);
    List<OfferModel> offersList = [];
    hitList.forEach((map) {
      Map<String, dynamic> sourceMap = map['_source'];

      if (!(user != null && isMemberBlocked(user, sourceMap["sevauserid"]))) {
        try {
          offersList.add(OfferModel.fromMapElasticSearch(sourceMap));
        } on Exception catch (e) {
          logger.e(e);
        }
      }
    });
    return offersList;
  }

  static Future<List<CommunityModel>> searchCommunity({
    @required queryString,
  }) async {
    String endPoint = '//elasticsearch/sevaxcommunities/_doc/_search';
    dynamic body = json.encode({
      "query": {
        "bool": {
          "must": [
            {
              "term": {
                "softDelete": false,
              }
            },
            {
              "term": {
                "private": false,
              }
            },
            {
              "term": {
                "softDelete": false,
              }
            },
            {
              "multi_match": {
                "query": queryString,
                "fields": ["name"],
                "type": "phrase_prefix"
              }
            }
          ]
        }
      },
      "sort": {
        "name.keyword": {"order": "asc"}
      }
    });

    List<Map<String, dynamic>> hitList =
        await _makeElasticSearchPostRequest(endPoint, body);
    List<CommunityModel> communityList = [];
    hitList.forEach((map) {
      try {
        Map<String, dynamic> sourceMap = map['_source'];
        communityList.add(CommunityModel(sourceMap));
      } on Exception catch (e) {
        logger.e(e);
      }
    });
    communityList.sort((a, b) => a.name.compareTo(b.name));
    return communityList;
  }

  static Future<List<OfferModel>> getPublicOffers() async {
    String endPoint = '//elasticsearch/offers/_doc/_search';

    dynamic body = json.encode({
      "query": {
        "bool": {
          "must": [
            {
              "term": {"private": false}
            },
            {
              "term": {"softDelete": false}
            }
          ]
        }
      }
    });
    List<Map<String, dynamic>> hitList = await _makeElasticSearchPostRequest(
      endPoint,
      body,
    );
    List<OfferModel> models = [];
    hitList.forEach((map) {
      Map<String, dynamic> sourceMap = map['_source'];
      OfferModel model = OfferModel.fromMap(sourceMap);
      models.add(model);
    });
    models.sort((a, b) => a.fullName.compareTo(b.fullName));
    return models;
  }

  static Future<List<CommunityModel>> getPublicCommunities() async {
    String endPoint = '//elasticsearch/sevaxcommunities/_doc/_search';

    dynamic body = json.encode({
      "query": {
        "bool": {
          "must": [
            {
              "term": {"private": false}
            },
            {
              "term": {"softDelete": false}
            }
          ]
        }
      }
    });
    List<Map<String, dynamic>> hitList =
        await _makeElasticSearchPostRequest(endPoint, body);
    List<CommunityModel> models = [];

    hitList.forEach((map) {
      Map<String, dynamic> sourceMap = map['_source'];
      CommunityModel model = CommunityModel(sourceMap);
      models.add(model);
    });
    models.sort((a, b) => a.name.compareTo(b.name));
    return models;
  }

  static Future<List<RequestModel>> getPublicRequests() async {
    String endPoint = '//elasticsearch/requests/request/_search';
    dynamic body = json.encode(
      {
        "query": {
          "bool": {
            "must": [
              {
                "term": {"private": false}
              },
              {
                "term": {"softDelete": false}
              }
            ]
          }
        }
      },
    );
    List<Map<String, dynamic>> hitList =
        await _makeElasticSearchPostRequest(endPoint, body);
    List<RequestModel> models = [];

    hitList.forEach((map) {
      Map<String, dynamic> sourceMap = map['_source'];
      RequestModel model = RequestModel.fromMap(sourceMap);
      models.add(model);
    });
    models.sort((a, b) => a.title.compareTo(b.title));
    return models;
  }

  static Future<List<ProjectModel>> getPublicProjects() async {
    String endPoint = '//elasticsearch/sevaxprojects/_doc/_search';
    dynamic body = json.encode({
      "query": {
        "bool": {
          "must": [
            {
              "term": {"private": false}
            },
            {
              "term": {"softDelete": false}
            }
          ]
        }
      }
    });
    List<Map<String, dynamic>> hitList =
        await _makeElasticSearchPostRequest(endPoint, body);
    List<ProjectModel> models = [];
    hitList.forEach((map) {
      Map<String, dynamic> sourceMap = map['_source'];
      ProjectModel model = ProjectModel.fromMap(sourceMap);
      models.add(model);
    });
    models.sort((a, b) => a.name.compareTo(b.name));
    return models;
  }
}
