import 'dart:convert';

// import 'package:firebase_crashlytics/firebase_crashlytics.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:http/http.dart' as http;
import 'package:sevaexchange/flavor_config.dart';
import 'package:sevaexchange/l10n/l10n.dart';
import 'package:sevaexchange/models/category_model.dart';
import 'package:sevaexchange/models/community_category_model.dart';
import 'package:sevaexchange/models/offer_model.dart';
import 'package:sevaexchange/models/request_model.dart';
import 'package:sevaexchange/models/user_model.dart';
import 'package:sevaexchange/new_baseline/models/community_model.dart';
import 'package:sevaexchange/new_baseline/models/project_model.dart';
import 'package:sevaexchange/ui/utils/location_helper.dart';
import 'package:sevaexchange/utils/app_config.dart';
import 'package:sevaexchange/utils/log_printer/log_printer.dart';
import 'package:sevaexchange/utils/search_via_zipcode.dart';

class ElasticSearchApi {
  static final _url = FlavorConfig.values.elasticSearchBaseURL;

  static Future<List<Map<String, dynamic>>> _makeElasticSearchPostRequest(
      String url, dynamic body) async {
    http.Response response = await http
        .post(
          _url + url,
          body: body,
          headers: {
            'authorization': 'basic dXNlcjpDaU4zNlVOaXhKeXE=',
            "Accept": "application/json",
            "Content-Type": "application/json"
          },
        )
        .timeout(Duration(
          seconds: 5,
        ))
        .onError((error, stackTrace) {
          return Future.error(error);
        });

    Map<String, dynamic> bodyMap = json.decode(response.body);
    Map<String, dynamic> hitMap = bodyMap['hits'];
    List<Map<String, dynamic>> hitList = List.castFrom(hitMap['hits']);

    return hitList;
  }

  static Future<List<RequestModel>> searchPublicRequests({
    @required String queryString,
    UserModel user,
    DistanceFilterData distanceFilterData,
  }) async {
    String endPoint = '//elasticsearch/requests/request/_search';
    logger.d('hitting', endPoint);
    dynamic body = json.encode(
      {
        "size": 3000,
        "query": {
          "bool": {
            "must": [
              {
                "term": {
                  "public": true,
                },
              },
              {
                "term": {
                  "softDelete": false,
                },
              },
              {
                "term": {
                  "autoGenerated": false,
                },
              },
              {
                "multi_match": {
                  "query": queryString,
                  "fields": ["description", "email", "fullname", "title"],
                  "type": "phrase_prefix"
                }
              }
            ]
          }
        }
      },
    );
    // List<Map<String, dynamic>> hitList =
    //     await _makeElasticSearchPostRequest(endPoint, body);

    List<Map<String, dynamic>> hitList;
    try {
      hitList = await _makeElasticSearchPostRequest(endPoint, body);
    } catch (e) {
      return Future.error("error");
    }

    List<RequestModel> requestsList = [];
    hitList.forEach((map) {
      Map<String, dynamic> sourceMap = map['_source'];
      RequestModel model = RequestModel.fromMapElasticSearch(sourceMap);
      if (distanceFilterData?.isInRadius(model.location) ?? true) {
        if (AppConfig.isTestCommunity != null && AppConfig.isTestCommunity) {
          if (!model.liveMode) requestsList.add(model);
        } else {
          requestsList.add(model);
        }
      }
    });
    return requestsList;
  }

  static Future<List<ProjectModel>> searchPublicEvents({
    @required String queryString,
    UserModel user,
    DistanceFilterData distanceFilterData,
  }) async {
    String endPoint = '//elasticsearch/sevaxprojects/_doc/_search';
    dynamic body = json.encode(
      {
        "sort": {
          "start_time": {"order": "desc"}
        },
        "size": 3000,
        "query": {
          "bool": {
            "must": [
              {
                "term": {
                  "public": true,
                },
              },
              {
                "term": {
                  "softDelete": false,
                },
              },
              {
                "multi_match": {
                  "query": queryString,
                  "fields": ["address", "description", "email_id", "name"],
                  "type": "phrase_prefix"
                }
              }
            ]
          }
        }
      },
    );
    // List<Map<String, dynamic>> hitList =
    //     await _makeElasticSearchPostRequest(endPoint, body);

    List<Map<String, dynamic>> hitList;
    try {
      hitList = await _makeElasticSearchPostRequest(endPoint, body);
    } catch (e) {
      return Future.error("error");
    }
    List<ProjectModel> projectsList = [];
    hitList.forEach((map) {
      Map<String, dynamic> sourceMap = map['_source'];
      ProjectModel model = ProjectModel.fromMap(sourceMap);
      if (distanceFilterData?.isInRadius(model.location) ?? true) {
        try {
          if (AppConfig.isTestCommunity != null && AppConfig.isTestCommunity) {
            if (!model.liveMode) projectsList.add(model);
          } else {
            projectsList.add(model);
          }
        } on Exception catch (e) {
          logger.e(e);
        }
      }
    });
    projectsList.sort((a, b) => a.name.compareTo(b.name));
    return projectsList;
  }

  static Future<List<OfferModel>> searchPublicOffers({
    @required queryString,
    UserModel user,
    DistanceFilterData distanceFilterData,
  }) async {
    String endPoint = '//elasticsearch/offers/_doc/_search';

    dynamic body = json.encode({
      "size": 3000,
      "query": {
        "bool": {
          "must": [
            {
              "term": {
                "softDelete": false,
              },
            },
            {
              "term": {
                "autoGenerated": false,
              },
            },
            {
              "term": {
                "public": true,
              },
            },
            {
              "bool": {
                "should": [
                  {
                    "nested": {
                      "path": "individualOfferDataModel",
                      "query": {
                        "bool": {
                          "should": {
                            "multi_match": {
                              "query": queryString,
                              "fields": [
                                "individualOfferDataModel.description",
                                "individualOfferDataModel.title"
                              ],
                              "type": "phrase_prefix"
                            }
                          }
                        }
                      }
                    }
                  },
                  {
                    "nested": {
                      "path": "groupOfferDataModel",
                      "query": {
                        "bool": {
                          "should": {
                            "multi_match": {
                              "query": queryString,
                              "fields": [
                                "groupOfferDataModel.classDescription",
                                "groupOfferDataModel.classTitle"
                              ],
                              "type": "phrase_prefix"
                            }
                          }
                        }
                      }
                    }
                  },
                  {
                    "multi_match": {
                      "query": queryString,
                      "fields": ["email", "fullname", "selectedAdrress"],
                      "type": "phrase_prefix"
                    }
                  }
                ]
              }
            }
          ]
        }
      }
    });

    // List<Map<String, dynamic>> hitList =
    //     await _makeElasticSearchPostRequest(endPoint, body);

    List<Map<String, dynamic>> hitList;
    try {
      hitList = await _makeElasticSearchPostRequest(endPoint, body);
    } catch (e) {
      return Future.error("error");
    }

    List<OfferModel> offersList = [];
    hitList.forEach((map) {
      Map<String, dynamic> sourceMap = map['_source'];
      OfferModel model = OfferModel.fromMapElasticSearch(sourceMap);
      if (distanceFilterData?.isInRadius(model.location) ?? true) {
        try {
          if (AppConfig.isTestCommunity != null && AppConfig.isTestCommunity) {
            if (!model.liveMode) offersList.add(model);
          } else {
            offersList.add(model);
          }
        } on Exception catch (e) {
          logger.e(e);
        }
      }
    });
    return offersList;
  }

  static Future<List<CommunityModel>> searchCommunity({
    @required queryString,
    DistanceFilterData distanceFilterData,
  }) async {
    dynamic body = json.encode({
      "query": {
        "bool": {
          "must": [
            {
              "term": {
                "softDelete": false,
              }
            },
            {
              "term": {
                "private": false,
              }
            },
            {
              "multi_match": {
                "query": queryString,
                "fields": [
                  "name",
                  "billing_address.country",
                  "billing_address.city",
                  "billing_address.state",
                ],
                "type": "phrase_prefix"
              }
            }
          ]
        }
      },
      "sort": {
        "name.keyword": {"order": "asc"}
      }
    });

    Map<String, CommunityModel> communityData = {};
    try {
      List<CommunityModel> communityListTemp =
          await SearchCommunityViaZIPCode.getCommunitiesViaZIPCode(queryString);

      communityListTemp.forEach((item) {
        logger.i("-----------First Community Name  " + communityListTemp[0].name);
        communityData[item.id] = item;
      });
    } on NoNearByCommunitesFoundException catch (e) {
      logger.i("NoNearByCommunitesViaZIPFoundException");
      // FirebaseCrashlytics.instance
      //     .log('NoNearByCommunitesViaZIPFoundException');
    }

    String endPoint = '//elasticsearch/sevaxcommunities/_doc/_search';
    // dynamic body = json.encode({
    //   "query": {
    //     "bool": {
    //       "must": [
    //         {
    //           "term": {
    //             "softDelete": false,
    //           }
    //         },
    //         {
    //           "term": {
    //             "private": false,
    //           }
    //         },
    //         {
    //           "term": {
    //             "softDelete": false,
    //           }
    //         },
    //         {
    //           "multi_match": {
    //             "query": queryString,
    //             "fields": ["name"],
    //             "type": "phrase_prefix"
    //           }
    //         }
    //       ]
    //     }
    //   },
    //   "sort": {
    //     "name.keyword": {"order": "asc"}
    //   }
    // });

    // List<Map<String, dynamic>> hitList =
    //     await _makeElasticSearchPostRequest(endPoint, body);

    List<Map<String, dynamic>> hitList;
    try {
      hitList = await _makeElasticSearchPostRequest(endPoint, body);
    } catch (e) {
      return Future.error("error");
    }

    hitList.forEach((map) {
      try {
        Map<String, dynamic> sourceMap = map['_source'];
        CommunityModel model = CommunityModel(sourceMap);
        if (distanceFilterData?.isInRadius(model.location) ?? true) {
          if (AppConfig.isTestCommunity != null && AppConfig.isTestCommunity) {
            if (model.testCommunity) communityData[model.id] = model;
          } else {
            communityData[model.id] = model;
          }
        }
      } on Exception catch (e) {
        logger.e(e);
      }
    });
    List<CommunityModel> communityList = communityData.values.toList();
    communityList.sort((a, b) => a.name.compareTo(b.name));

    logger.i("Length of FINAL COMMUNITY LIST:  " + communityList.length.toString());

    return communityList;
  }

  static Future<List<OfferModel>> getPublicOffers({
    DistanceFilterData distanceFilterData,
  }) async {
    String endPoint = '//elasticsearch/offers/_doc/_search?size=1000';

    dynamic body = json.encode({
      "query": {
        "bool": {
          "must": [
            {
              "term": {"public": true}
            },
            {
              "term": {"softDelete": false}
            },
            {
              "term": {"autoGenerated": false}
            }
          ]
        }
      }
    });
    // List<Map<String, dynamic>> hitList = await _makeElasticSearchPostRequest(
    //   endPoint,
    //   body,
    // );

    List<Map<String, dynamic>> hitList;
    try {
      hitList = await _makeElasticSearchPostRequest(endPoint, body);
    } catch (e) {
      return Future.error("error");
    }

    List<OfferModel> models = [];
    logger.i("Total Offer from Elastic ");
    hitList.forEach((map) {
      Map<String, dynamic> sourceMap = map['_source'];
      OfferModel model = OfferModel.fromMap(sourceMap);
      logger.i(">>>>>>>>>>>> OFFER TYPE : " + model.type.toString());
      if (distanceFilterData?.isInRadius(model.location) ?? true) {
        if (AppConfig.isTestCommunity != null && AppConfig.isTestCommunity) {
          if (!model.liveMode) models.add(model);
        } else {
          models.add(model);
        }
      }
    });
    models.sort((a, b) => a.fullName.compareTo(b.fullName));
    return models;
  }

  static Future<List<CommunityModel>> getPublicCommunities({
    DistanceFilterData distanceFilterData,
  }) async {
    String endPoint = '//elasticsearch/sevaxcommunities/_doc/_search?size=1000';

    dynamic body = json.encode({
      "query": {
        "bool": {
          "must": [
            {
              "term": {"private": false}
            },
            {
              "term": {"softDelete": false}
            }
          ]
        }
      }
    });

    List<Map<String, dynamic>> hitList;
    try {
      hitList = await _makeElasticSearchPostRequest(endPoint, body);
    } catch (e) {
      return Future.error("error");
    }
    // List<Map<String, dynamic>> hitList =
    //     await _makeElasticSearchPostRequest(endPoint, body);

    List<CommunityModel> models = [];

    hitList.forEach((map) {
      Map<String, dynamic> sourceMap = map['_source'];
      CommunityModel model = CommunityModel(sourceMap);
      if (distanceFilterData?.isInRadius(model.location) ?? true) {
        if (AppConfig.isTestCommunity != null && AppConfig.isTestCommunity) {
          if (model.testCommunity) models.add(model);
        } else {
          models.add(model);
        }
      }
    });
    models.sort((a, b) => a.name.compareTo(b.name));
    return models;
  }

  static Future<List<RequestModel>> getPublicRequests({
    DistanceFilterData distanceFilterData,
  }) async {
    String endPoint = '//elasticsearch/requests/request/_search?size=1000';
    dynamic body = json.encode(
      {
        "query": {
          "bool": {
            "must": [
              {
                "term": {"public": true}
              },
              {
                "term": {"softDelete": false}
              },
              {
                "term": {"autoGenerated": false}
              }
            ]
          }
        },
        "sort": {
          "posttimestamp": {"order": "desc"}
        }
      },
    );

    List<Map<String, dynamic>> hitList;
    try {
      hitList = await _makeElasticSearchPostRequest(endPoint, body);
    } catch (e) {
      return Future.error("error");
    }

    // List<Map<String, dynamic>> hitList =
    //     await _makeElasticSearchPostRequest(endPoint, body);

    List<RequestModel> models = [];

    hitList.forEach((map) {
      Map<String, dynamic> sourceMap = map['_source'];
      RequestModel model = RequestModel.fromMap(sourceMap);
      if (distanceFilterData?.isInRadius(model.location) ?? true) {
        if (AppConfig.isTestCommunity != null && AppConfig.isTestCommunity) {
          if (!model.liveMode) models.add(model);
        } else {
          models.add(model);
        }
      }
    });
    return models;
  }

  //get all categories

  static Future<List<CategoryModel>> getAllCategories(BuildContext context) async {
    var key = S.of(context).localeName;

    String endPoint = '//elasticsearch/request_categories/_doc/_search?size=200';

    dynamic body = json.encode({
      "query": {"match_all": {}},
      "sort": {
        "title_en.keyword": {"order": "asc"}
      }
    });

    List<Map<String, dynamic>> hitList;
    try {
      hitList = await _makeElasticSearchPostRequest(endPoint, body);
    } catch (e) {
      return Future.error("error");
    }
    // List<Map<String, dynamic>> hitList =
    //     await _makeElasticSearchPostRequest(endPoint, body);

    List<CategoryModel> categoryList = [];

    // log('Elastic seach categories result:  ' + hitList.toString());

    hitList.forEach((map) {
      Map<String, dynamic> sourceMap = map['_source'];
      if (sourceMap["title_" + key ?? 'en'] != null) {
        CategoryModel model = CategoryModel.fromMap(sourceMap);
        categoryList.add(model);
      }
    });
    return categoryList;
  }

  // get all community categories
  static Future<List<CommunityCategoryModel>> getAllCommunityCategories() async {
    String endPoint = '//elasticsearch/community_categories/_doc/_search?size=200';

    dynamic body = json.encode({
      "query": {"match_all": {}},
      "sort": {
        "en.keyword": {"order": "asc"}
      }
    });

    List<Map<String, dynamic>> hitList;
    try {
      hitList = await _makeElasticSearchPostRequest(endPoint, body);
    } catch (e) {
      return Future.error("error");
    }

    // List<Map<String, dynamic>> hitList =
    //     await _makeElasticSearchPostRequest(endPoint, body);

    List<CommunityCategoryModel> categoryList = [];

    hitList.forEach((map) {
      Map<String, dynamic> sourceMap = map['_source'];
      CommunityCategoryModel model = CommunityCategoryModel.fromMap(sourceMap);
      categoryList.add(model);
    });
    return categoryList;
  }

  static Future<List<RequestModel>> getRequestsByCategory(typeId) async {
    String endPoint = '//elasticsearch/requests/request/_search';
    dynamic body = json.encode(
      {
        "query": {
          "bool": {
            "must": [
              {
                "term": {"public": true}
              },
              {
                "term": {"softDelete": false}
              },
              {
                "match": {"categories": typeId}
              },
            ]
          }
        }
      },
    );
    // List<Map<String, dynamic>> hitList =
    //     await _makeElasticSearchPostRequest(endPoint, body);

    List<Map<String, dynamic>> hitList;
    try {
      hitList = await _makeElasticSearchPostRequest(endPoint, body);
    } catch (e) {
      return Future.error("error");
    }
    List<RequestModel> models = [];
    hitList.forEach((map) {
      Map<String, dynamic> sourceMap = map['_source'];
      RequestModel model = RequestModel.fromMap(sourceMap);
      models.add(model);
    });
    models.sort((a, b) => a.title.compareTo(b.title));
    return models;
  }

  static Future<List<ProjectModel>> getPublicProjects(
      {DistanceFilterData distanceFilterData, String sevaUserID, bool showCompletedEvent}) async {
    logger.e('USER ID CHECK 6');
    String endPoint = '//elasticsearch/sevaxprojects/_doc/_search?size=1000';
    dynamic body = json.encode({
      "sort": {
        "start_time": {"order": "desc"}
      },
      "query": {
        "bool": {
          "must": [
            {
              "term": {"public": true}
            },
            {
              "term": {"softDelete": false}
            },
            {
              "term": {"autoGenerated": false}
            }
          ]
        }
      }
    });
    List<Map<String, dynamic>> hitList;
    try {
      hitList = await _makeElasticSearchPostRequest(endPoint, body);
    } catch (e) {
      return Future.error("error");
    }
    List<ProjectModel> models = [];
    hitList.forEach((map) {
      Map<String, dynamic> sourceMap = map['_source'];
      ProjectModel model = ProjectModel.fromMap(sourceMap);
      bool compareDates = false;
      if (distanceFilterData?.isInRadius(model.location) ?? true) {
        DateTime endDate = DateTime.fromMillisecondsSinceEpoch(model.endTime);

        logger.e('USER ID CHECK 2:  ' + sevaUserID);

        //explore events listing page
        if (showCompletedEvent) {
          if (endDate.isAfter(DateTime.now().subtract(Duration(days: 365))) &&
              endDate.isBefore(DateTime.now())) {
            if (AppConfig.isTestCommunity != null && AppConfig.isTestCommunity) {
              if (!model.liveMode) models.add(model);
            } else {
              models.add(model);
            }
          }
        } else {
          if (endDate.isBefore(DateTime.now())) {
            if ((sevaUserID != null || sevaUserID != '') &&
                (model.creatorId == sevaUserID ||
                    model.members.contains(sevaUserID) ||
                    model.associatedmembers.containsKey(sevaUserID))) {
              if (AppConfig.isTestCommunity != null && AppConfig.isTestCommunity) {
                if (!model.liveMode) models.add(model);
              } else {
                models.add(model);
              }
            }
          } else {
            if (AppConfig.isTestCommunity != null && AppConfig.isTestCommunity) {
              if (!model.liveMode) models.add(model);
            } else {
              models.add(model);
            }
          }
        }
      }
    });
    return models;
  }

  static Future<List<CommunityModel>> getCommunitiesByCategory(String communityCategoryId) async {
    String endPoint = '//elasticsearch/sevaxcommunities/_doc/_search';
    dynamic body = json.encode({
      "query": {
        "bool": {
          "must": [
            {
              "query_string": {"default_field": "communityCategories", "query": communityCategoryId}
            },
            {
              "term": {"private": false}
            },
            {
              "term": {"softDelete": false}
            }
          ]
        }
      }
    });
    List<Map<String, dynamic>> hitList;
    try {
      hitList = await _makeElasticSearchPostRequest(endPoint, body);
    } catch (e) {
      return Future.error("error");
    }
    List<CommunityModel> models = [];
    hitList.forEach((map) {
      Map<String, dynamic> sourceMap = map['_source'];
      CommunityModel model = CommunityModel(sourceMap);
      models.add(model);
    });
    models.sort((a, b) => a.name.compareTo(b.name));
    return models;
  }

  static Future<List<CommunityModel>> getFeaturedCommunities() async {
    String endPoint = '//elasticsearch/sevaxcommunities/_doc/_search?size=10';

    dynamic body = json.encode({
      "query": {
        "bool": {
          "must": [
            {
              "term": {
                "testCommunity": AppConfig.isTestCommunity != null && AppConfig.isTestCommunity
              }
            },
            {
              "term": {"private": false}
            },
            {
              "term": {"softDelete": false}
            }
          ]
        }
      },
      "sort": {
        "featuredCommunity": {"order": "desc"}
      }
    });

    List<Map<String, dynamic>> hitList;
    try {
      hitList = await _makeElasticSearchPostRequest(endPoint, body);
    } catch (e) {
      return Future.error("error");
    }

    List<CommunityModel> models = [];
    // logger.wtf(hitList.length.toString() +
    //     "<><><><><><><><><><>>>>>>>>>>><<<<<<<<<<<");
    hitList.forEach((map) {
      Map<String, dynamic> sourceMap = map['_source'];

      CommunityModel model = CommunityModel(sourceMap);
      logger.e("featured community", sourceMap['featuredCommunity']);
      models.add(model);
    });
    // models.sort((a, b) => a.name.compareTo(b.name));
    return models;
  }
}
