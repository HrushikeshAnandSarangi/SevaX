import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:rxdart/rxdart.dart';
import 'package:rxdart/subjects.dart';
import 'package:sevaexchange/components/ProfanityDetector.dart';
import 'package:sevaexchange/models/models.dart';
import 'package:sevaexchange/models/user_model.dart';
import 'package:sevaexchange/ui/utils/offer_utility.dart';
import 'package:sevaexchange/ui/utils/validators.dart';
import 'package:sevaexchange/utils/bloc_provider.dart';
import 'package:sevaexchange/utils/data_managers/offers_data_manager.dart';

import '../../../../flavor_config.dart';

class OneToManyOfferBloc extends BlocBase {
  int startTime;
  int endTime;
  bool offerCreatedBool = false;
  bool autoGenerated = false;
  bool allowedCalenderEvent = false;
  bool isRecurring = false;
  List<int> recurringDays = [];
  int occurenceCount;
  End end;
  String parent_offer_id;
  OfferModel mainOfferModel = null;
  List<String> offerIds = [];
  final _makePublic = BehaviorSubject<bool>();
  final _makeVirtual = BehaviorSubject<bool>();

  final _title = BehaviorSubject<String>();
  final _preparationHours = BehaviorSubject<String>();
  final _classHours = BehaviorSubject<String>();
  final _classSize = BehaviorSubject<String>();
  final _classDescription = BehaviorSubject<String>();
  final _location = BehaviorSubject<CustomLocation>();
  final _status = BehaviorSubject<Status>.seeded(Status.IDLE);
  final _classSizeError = BehaviorSubject<String>();
  final profanityDetector = ProfanityDetector();
  final _isAdmin = BehaviorSubject<bool>.seeded(false);

  Function(bool value) get onOfferMadePublic => _makePublic.sink.add;
  Function(bool value) get onOfferMadeVirtual => _makeVirtual.sink.add;

  Function(String value) get onTitleChanged => _title.sink.add;
  Function(String) get onPreparationHoursChanged => _preparationHours.sink.add;
  Function(String) get onClassHoursChanged => _classHours.sink.add;
  Function(String) get onClassSizeChanged => _classSize.sink.add;
  Function(String) get onclassDescriptionChanged => _classDescription.sink.add;
  Function(CustomLocation) get onLocatioChanged => _location.sink.add;
  Function(String) get onClassSizeError => _classSizeError.sink.add;
  Function(bool) get isAdminChanged => _isAdmin.sink.add;

  Stream<bool> get makePublicValue => _makePublic.stream;
  Stream<bool> get makeVirtualValue => _makeVirtual.stream;

  Stream<String> get title => _title.stream;
  Stream<String> get preparationHours => _preparationHours.stream;
  Stream<String> get classHours => _classHours.stream;
  Stream<String> get classSize => _classSize.stream;
  Stream<bool> get isAdmin => _isAdmin.stream;
  Stream<String> get classDescription => _classDescription.stream;
  Stream<CustomLocation> get location => _location.stream;
  Stream<String> get classSizeError => _classSizeError.stream;

  Stream<Status> get status => _status.stream;

  ///[Function] to create or update offer
  void createOneToManyOffer({
    UserModel user,
    String timebankId,
  }) async {
    if (!errorCheck()) {
      int prepHours = int.parse(_preparationHours.value);
      int classHours = int.parse(_classHours.value);
      int classSize = int.parse(_classSize.value);

      if (prepHours + classHours < classSize * classHours) {
        _status.add(Status.LOADING);
        var timestamp = DateTime.now().millisecondsSinceEpoch;
        var id = '${user.email}*$timestamp';
        var parent_offer_id = id;

        OfferModel offerModel = OfferModel(
          id: id,
          email: user.email,
          softDelete: false,
          fullName: user.fullname,
          sevaUserId: user.sevaUserID,
          timebankId: timebankId,
          communityId: user.currentCommunity,
          creatorAllowedCalender: allowedCalenderEvent,
          allowedCalenderUsers: allowedCalenderEvent ? [user.email] : [],
          selectedAdrress:
              _location.value == null ? null : _location.value.address,
          timestamp: timestamp,
          location: _location.value == null ? null : _location.value.location,
          public: _makePublic.value ?? false,
          virtual: _makeVirtual.value ?? false,
          timebanksPosted: _makePublic.value ?? false
              ? [timebankId, FlavorConfig.values.timebankId]
              : [timebankId],
          groupOfferDataModel: GroupOfferDataModel()
            ..classTitle = _title.value
            ..startDate = startTime
            ..endDate = endTime
            ..numberOfPreperationHours = prepHours
            ..numberOfClassHours = classHours
            ..sizeOfClass = classSize
            ..classDescription = _classDescription.value,
          individualOfferDataModel: IndividualOfferDataModel(),
          offerType: OfferType.GROUP_OFFER,
        );
        offerModel.autoGenerated = autoGenerated;
        offerModel.isRecurring = isRecurring;
        if (offerModel.isRecurring) {
          offerModel.recurringDays = recurringDays;
          offerModel.end = end;
          offerModel.occurenceCount = occurenceCount;
          offerModel.parent_offer_id = parent_offer_id;
        }

        await createOffer(offerModel: offerModel).then((_) {
          offerIds.add(offerModel.id);
          if (offerModel.isRecurring) {
            return createRecurringEventsOffer(offerModel: offerModel);
          }
        }).then((offerIdsList) {
          if (offerModel.isRecurring) {
            offerIdsList.forEach((Id) {
              offerIds.add(Id);
            });
          }
          offerCreatedBool = true;
          mainOfferModel = offerModel;
          _status.add(Status.COMPLETE);
        }).catchError((e) => _status.add(Status.ERROR));
      } else {
        _classSizeError.add(ValidationErrors.offerCreditError);
      }
    }
  }

  void updateOneToManyOffer(OfferModel offerModel, int editType) {
    OfferModel offer = offerModel;
    if (!errorCheck()) {
      int prepHours = int.parse(_preparationHours.value);
      int classHours = int.parse(_classHours.value);
      int classSize = int.parse(_classSize.value);
      if (prepHours + classHours < classSize * classHours) {
        _status.add(Status.LOADING);
        offer.location = _location.value.location;
        offer.selectedAdrress = _location.value.address;
        offer.public = _makePublic.value ?? false;
        offer.virtual = _makeVirtual.value;
        offer.timebanksPosted = _makeVirtual.value
            ? [offer.timebankId, FlavorConfig.values.timebankId]
            : [offer.timebankId];
        offer.groupOfferDataModel = GroupOfferDataModel()
          ..classTitle = _title.value
          ..startDate = startTime
          ..endDate = endTime
          ..numberOfPreperationHours = prepHours
          ..numberOfClassHours = classHours
          ..sizeOfClass = classSize
          ..classDescription = _classDescription.value;

        offer.autoGenerated = autoGenerated;
        offer.isRecurring = isRecurring;

        if (offer.isRecurring || offer.autoGenerated) {
          offer.recurringDays = recurringDays;
          offer.end = end;
          offer.occurenceCount = occurenceCount;
        }

        updateOfferWithRequest(offer: offer).then((_) {
          if (editType == 1) {
            return updateRecurrenceOffersFrontEnd(updatedOfferModel: offer);
          }
          return 1;
        }).then((_) {
          _status.add(Status.COMPLETE);
        }).catchError((e) => _status.add(Status.ERROR));
      } else {
        _classSizeError.add(ValidationErrors.offerCreditError);
      }
    }
  }

  void checkPublicAvailability(String timebankId, String sevaUserId) {
    Firestore.instance
        .collection('timebanknew')
        .document(timebankId)
        .get()
        .then((value) {
      final model = TimebankModel.fromMap(value.data);
      isAdminChanged(model.admins.contains(sevaUserId) ||
          model.organizers.contains(sevaUserId));
    });
  }

  ///[PRELOAD DATA FOR UPDATE]
  void loadData(OfferModel offerModel) {
    _title.add(
      offerModel.groupOfferDataModel.classTitle,
    );
    _preparationHours.add(
      offerModel.groupOfferDataModel.numberOfPreperationHours.toString(),
    );
    _classHours.add(
      offerModel.groupOfferDataModel.numberOfClassHours.toString(),
    );
    _classSize.add(offerModel.groupOfferDataModel.sizeOfClass.toString());
    _classDescription.add(
      offerModel.groupOfferDataModel.classDescription,
    );

    _makePublic.add(offerModel.public);
    _makeVirtual.add(offerModel.virtual);
    _location.add(
      CustomLocation(
        offerModel.location,
        offerModel.selectedAdrress,
      ),
    );
  }

  ///[ERROR CHECKS] TO Validate input
  bool errorCheck() {
    RegExp numberCheck = RegExp(r"^0*[1-9]\d*$");
    RegExp numberWithZeroCheck = RegExp(r"^\d+$");

    bool flag = false;
    if (_title.value == null || _title.value == '') {
      _title.addError(ValidationErrors.titleError);
      flag = true;
    } else {
      if (profanityDetector.isProfaneString(_title.value)) {
        _title.addError(ValidationErrors.profanityError);
        flag = true;
      }
    }
    if (_classDescription.value == null || _classDescription.value == '') {
      _classDescription.addError(ValidationErrors.genericError);
      flag = true;
    } else {
      if (profanityDetector.isProfaneString(_classDescription.value)) {
        _classDescription.addError(ValidationErrors.profanityError);
        flag = true;
      }
    }
    if (_classHours.value == null || !numberCheck.hasMatch(_classHours.value)) {
      _classHours.addError(ValidationErrors.classHours);
      flag = true;
    }

    if (_classSize.value == null || !numberCheck.hasMatch(_classSize.value)) {
      _classSize.addError(ValidationErrors.sizeOfClassError);
      flag = true;
    }

    if (_preparationHours.value == null ||
        !numberWithZeroCheck.hasMatch(_preparationHours.value)) {
      _preparationHours.addError(
        ValidationErrors.preprationTimeError,
      );
      flag = true;
    }
    return flag;
  }

  bool checkCreditError() {
    if (!errorCheck()) {
      int prepHours = int.parse(_preparationHours.value);
      int classHours = int.parse(_classHours.value);
      int classSize = int.parse(_classSize.value);

      if (prepHours + classHours > classSize * classHours) {
        return true;
      }
    }
    return false;
  }

  @override
  void dispose() {
    _title.close();
    _classDescription.close();
    _preparationHours.close();
    _classHours.close();
    _classSize.close();
    _location.close();
    _status.close();
    _classSizeError.close();
  }
}
