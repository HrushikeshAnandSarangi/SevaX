import 'dart:async';
import 'dart:convert';
import 'dart:developer';

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:geoflutterfire/geoflutterfire.dart';
import 'package:geolocator/geolocator.dart';
import 'package:location/location.dart';
import 'package:meta/meta.dart';
import 'package:sevaexchange/components/get_location.dart';
import 'package:sevaexchange/models/offer_model.dart';
import 'package:sevaexchange/models/request_model.dart';

import '../app_config.dart';

Location loc = Location();
Geoflutterfire geoflutterfire = Geoflutterfire();

Stream<List<OfferModel>> getOffersStream({String timebankId}) async* {
  var query = timebankId == null || timebankId == 'All'
      ? Firestore.instance
          .collection('offers')
          .where('assossiatedRequest', isNull: true)
          .where('softDelete', isEqualTo: false)
          .where('autoGenerated', isEqualTo: false)
      : Firestore.instance
          .collection('offers')
          .where('timebankId', isEqualTo: timebankId)
          .where('assossiatedRequest', isNull: true)
          .where('softDelete', isEqualTo: false)
          .where('autoGenerated', isEqualTo: false);

  var data = query.snapshots();

  yield* data.transform(
    StreamTransformer<QuerySnapshot, List<OfferModel>>.fromHandlers(
      handleData: (snapshot, offerSink) async {
        var futures = <Future>[];

        List<OfferModel> offerList = [];

        snapshot.documents.forEach((snapshot) {
          OfferModel model = OfferModel.fromMap(snapshot.data);
          futures.add(getUserInfo(model.email));
          model.id = snapshot.documentID;

          if (model.offerType == OfferType.GROUP_OFFER &&
              !model.groupOfferDataModel.isCanceled) {
            offerList.add(model);
          } else if (model.offerType == OfferType.INDIVIDUAL_OFFER) {
            offerList.add(model);
          }
        });

        await Future.wait(futures).then((onValue) {
          var i = 0;
          while (i < offerList.length) {
            offerList[i].photoUrlImage = onValue[i]['photourl'];
            i++;
          }
        });

        offerSink.add(offerList);
      },
    ),
  );
}

Future<DocumentSnapshot> getUserInfo(String userEmail) {
  return Firestore.instance
      .collection("users")
      .document(userEmail)
      .get()
      .then((onValue) {
    return onValue;
  });
}

Stream<List<OfferModel>> getNearOffersStream({String timebankId}) async* {
  // LocationData pos = await loc.getLocation();
  // double lat = pos.latitude;
  // double lng = pos.longitude;
  Geolocator geolocator = Geolocator();
  Position userLocation;

  userLocation = await geolocator.getCurrentPosition();
  double lat = userLocation.latitude;
  double lng = userLocation.longitude;

  GeoFirePoint center = geoflutterfire.point(latitude: lat, longitude: lng);
  var query = timebankId == null || timebankId == 'All'
      ? Firestore.instance
          .collection('offers')
          .where('assossiatedRequest', isNull: true)
          .where('softDelete', isEqualTo: false)
          .where('softDelete', isEqualTo: false)
      : Firestore.instance
          .collection('offers')
          .where('timebankId', isEqualTo: timebankId)
          .where('assossiatedRequest', isNull: true)
          .where('softDelete', isEqualTo: false);

  var radius = 20;
  try {
    radius = json.decode(AppConfig.remoteConfig.getString('radius'));
  } on Exception {
    print("Exception raised while getting user minimum balance ");
  }
  print(
      "radius is fetched from remote config near offers ${radius.toDouble()}");

  var data = geoflutterfire.collection(collectionRef: query).within(
      center: center,
      radius: radius.toDouble(),
      field: 'location',
      strictMode: true);

  yield* data.transform(
    StreamTransformer<List<DocumentSnapshot>, List<OfferModel>>.fromHandlers(
      handleData: (snapshot, offerSink) {
        List<OfferModel> offerList = [];
        snapshot.forEach((snapshot) {
          OfferModel model = OfferModel.fromMap(snapshot.data);
          model.id = snapshot.documentID;
          offerList.add(model);
        });
        offerSink.add(offerList);
      },
    ),
  );
}

Stream<List<OfferModel>> getAllOffersStream() async* {
  var query = Firestore.instance
      .collection('offers')
      .where('assossiatedRequest', isNull: true);

  var data = query.snapshots();

  yield* data.transform(
    StreamTransformer<QuerySnapshot, List<OfferModel>>.fromHandlers(
      handleData: (snapshot, offerSink) {
        List<OfferModel> offerList = [];
        snapshot.documents.forEach((snapshot) {
          OfferModel model = OfferModel.fromMap(snapshot.data);
          model.id = snapshot.documentID;
          offerList.add(model);
        });
        offerSink.add(offerList);
      },
    ),
  );
}

Future<void> createOffer({@required OfferModel offerModel}) async {
  await Firestore.instance
      .collection('offers')
      .document(offerModel.id)
      .setData(offerModel.toMap());
}

Future<int> createRecurringEventsOffer({@required OfferModel offerModel}) async {
  var batch = Firestore.instance.batch();
  var db = Firestore.instance;
  bool lastRound = false;
  DateTime eventStartDate =
  DateTime.fromMillisecondsSinceEpoch(offerModel.groupOfferDataModel.startDate),
      eventEndDate =
      DateTime.fromMillisecondsSinceEpoch(offerModel.groupOfferDataModel.endDate);
  List<Map<String, dynamic>> temparr = [];
  DocumentSnapshot projectDoc = null;


  if (offerModel.end.endType == "on") {
    //end type is on
    int occurenceCount = 2;
    var numTemp = 0;
    while (lastRound == false) {

      eventStartDate = DateTime(eventStartDate.year, eventStartDate.month, eventStartDate.day + 1, eventStartDate.hour, eventStartDate.minute, eventStartDate.second);
      eventEndDate = DateTime(eventEndDate.year, eventEndDate.month, eventEndDate.day + 1, eventEndDate.hour, eventEndDate.minute, eventEndDate.second);

      if (eventStartDate.millisecondsSinceEpoch <= offerModel.end.on &&
          occurenceCount < 11) {
        numTemp = eventStartDate.weekday % 7;
        if (offerModel.recurringDays.contains(numTemp)) {
          OfferModel temp = offerModel;
          temp.groupOfferDataModel.startDate = eventStartDate.millisecondsSinceEpoch;
          temp.groupOfferDataModel.endDate = eventEndDate.millisecondsSinceEpoch;
          temp.timestamp = DateTime.now().millisecondsSinceEpoch;
          temp.id = temp.email + "*" + temp.timestamp.toString() + "*" + temp.groupOfferDataModel.startDate.toString();
          temp.occurenceCount = occurenceCount;
          occurenceCount++;
          temp.softDelete = false;
          temp.isRecurring = false;
          temp.autoGenerated = true;
          temparr.add(temp.toMap());
        }
      } else {
        lastRound = true;
        break;
      }
    }
  }
  else {
    //end type is after
    var numTemp = 0;
    int occurenceCount = 2;
    while (occurenceCount <= offerModel.end.after) {
      eventStartDate = DateTime(eventStartDate.year, eventStartDate.month, eventStartDate.day + 1, eventStartDate.hour, eventStartDate.minute, eventStartDate.second);
      eventEndDate = DateTime(eventEndDate.year, eventEndDate.month, eventEndDate.day + 1, eventEndDate.hour, eventEndDate.minute, eventEndDate.second);

      numTemp = eventStartDate.weekday % 7;
      if (offerModel.recurringDays.contains(numTemp)) {
        OfferModel temp = offerModel;
        temp.groupOfferDataModel.startDate = eventStartDate.millisecondsSinceEpoch;
        temp.groupOfferDataModel.endDate = eventEndDate.millisecondsSinceEpoch;
        temp.timestamp = DateTime.now().millisecondsSinceEpoch;
        temp.id = temp.email + "*" + temp.timestamp.toString() + "*" + temp.groupOfferDataModel.startDate.toString();
        temp.occurenceCount = occurenceCount;
        occurenceCount++;
        temp.softDelete = false;
        temp.isRecurring = false;
        temp.autoGenerated = true;
        temparr.add(temp.toMap());
      }
      if (occurenceCount > offerModel.end.after) {
        break;
      }
    }
  }

  temparr.forEach((tempobj) {
    batch.setData(db.collection("offers").document(tempobj['id']), tempobj);
    log("---------   ${DateTime.fromMillisecondsSinceEpoch(tempobj['groupOfferDataModel']['startDate']).toString()} with occurence count of ${tempobj['occurenceCount']}");
  });

  await batch.commit();
  return 1;
}

Future<void> updateRecurrenceOffersFrontEnd(
    {@required OfferModel updatedOfferModel}) async {
  var batch = Firestore.instance.batch();
  var db = Firestore.instance;
  bool lastRound = false;
  String uuidvar = "";
  OfferModel eventData, parentEvent;

  List<OfferModel> upcomingEventsArr = [], prevEventsArr = [];
  var futures = <Future>[];
  Set<String> usersIds = Set();
  DateTime eventStartDate =
  DateTime.fromMillisecondsSinceEpoch(updatedOfferModel.groupOfferDataModel.startDate),
      eventEndDate =
      DateTime.fromMillisecondsSinceEpoch(updatedOfferModel.groupOfferDataModel.endDate);

  QuerySnapshot snapEvents = await db.collection("offers").where("parent_offer_id", isEqualTo: updatedOfferModel.parent_offer_id).getDocuments();

  snapEvents.documents.forEach((eventDoc) {
    eventData = OfferModel.fromMap(eventDoc.data);
    if (eventData.occurenceCount == 1) {
      parentEvent = eventData;
    }
    else if (eventData.occurenceCount > updatedOfferModel.occurenceCount) {
      upcomingEventsArr.add(eventData);
    }
    else if (eventData.occurenceCount < updatedOfferModel.occurenceCount) {
      prevEventsArr.add(eventData);
    }
  });
  // s1 ---------- create set of events with updated data

  List<Map<String, dynamic>> temparr = [];

  if (updatedOfferModel.end.endType == "on") {
    //end type is on
    int occurenceCount = updatedOfferModel.occurenceCount + 1;
    var numTemp = 0;
    while (lastRound == false) {
      eventStartDate = DateTime(eventStartDate.year, eventStartDate.month, eventStartDate.day + 1, eventStartDate.hour, eventStartDate.minute, eventStartDate.second);
      eventEndDate = DateTime(eventEndDate.year, eventEndDate.month, eventEndDate.day + 1, eventEndDate.hour, eventEndDate.minute, eventEndDate.second);
      if (eventStartDate.millisecondsSinceEpoch <= updatedOfferModel.end.on &&
          occurenceCount < 11) {
        numTemp = eventStartDate.weekday % 7;
        if (updatedOfferModel.recurringDays.contains(numTemp)) {
          OfferModel temp = updatedOfferModel;
          temp.groupOfferDataModel.startDate = eventStartDate.millisecondsSinceEpoch;
          temp.groupOfferDataModel.endDate = eventEndDate.millisecondsSinceEpoch;
          temp.timestamp = DateTime.now().millisecondsSinceEpoch;
          temp.id = temp.email + "*" + temp.timestamp.toString() + "*" + temp.groupOfferDataModel.startDate.toString();
          temp.occurenceCount = occurenceCount;
          occurenceCount++;
          temp.softDelete = false;
          temp.isRecurring = false;
          temp.autoGenerated = true;
          temparr.add(temp.toMap());
        }
      } else {
        lastRound = true;
        break;
      }
    }
  }
  else {
    //end type is after
    var numTemp = 0;
    int occurenceCount = updatedOfferModel.occurenceCount + 1;
    while (occurenceCount <= updatedOfferModel.end.after) {
      eventStartDate = DateTime(eventStartDate.year, eventStartDate.month, eventStartDate.day + 1, eventStartDate.hour, eventStartDate.minute, eventStartDate.second);
      eventEndDate = DateTime(eventEndDate.year, eventEndDate.month, eventEndDate.day + 1, eventEndDate.hour, eventEndDate.minute, eventEndDate.second);
      numTemp = eventStartDate.weekday % 7;
      if (updatedOfferModel.recurringDays.contains(numTemp)) {
        OfferModel temp = updatedOfferModel;
        temp.groupOfferDataModel.startDate = eventStartDate.millisecondsSinceEpoch;
        temp.groupOfferDataModel.endDate = eventEndDate.millisecondsSinceEpoch;
        temp.timestamp = DateTime.now().millisecondsSinceEpoch;
        temp.id = temp.email + "*" + temp.timestamp.toString() + "*" + temp.groupOfferDataModel.startDate.toString();
        temp.occurenceCount = occurenceCount;
        occurenceCount++;
        temp.softDelete = false;
        temp.isRecurring = false;
        temp.autoGenerated = true;
        temparr.add(temp.toMap());
      }
      if (occurenceCount > updatedOfferModel.end.after) {
        break;
      }
    }
  }

  temparr.forEach((tempobj) {
    batch.setData(db.collection("offers").document(tempobj['id']), tempobj);
    log("---------   ${DateTime.fromMillisecondsSinceEpoch(tempobj['groupOfferDataModel']['startDate']).toString()} with occurence count of ${tempobj['occurenceCount']}");
  });

  // s2 ---------- update parent request and previous events with end data of updated event model

  batch.updateData(
      db.collection("offers").document(updatedOfferModel.parent_offer_id),
      {
        "end": updatedOfferModel.end.toMap(),
        "recurringDays": updatedOfferModel.recurringDays
      });

  // s3 ---------- delete old recurrences since the updated model

  if (upcomingEventsArr.length != 0) {
    upcomingEventsArr.forEach((upcomingEvent) {
      batch.delete(db
          .collection("offers")
          .document(upcomingEvent.id)); // delete old upcoming recurrence-events
    });
  }

  // s5 ---------- send notifications in case users have part of members

  upcomingEventsArr.forEach((upcomingEvent) {
    if (upcomingEvent.groupOfferDataModel.signedUpMembers.length > 0) {
      upcomingEvent.groupOfferDataModel.signedUpMembers.forEach((signedUpMemberId) {
        usersIds.add(signedUpMemberId);
      });
    }
  });
  List<String> usersIdsList = [];
  usersIdsList = usersIds.toList();
  int startIndex = 0, endIndex;

  if (usersIdsList.length > 0) {

    if(usersIdsList.length > 10) {
      for( endIndex = 10 ; endIndex < usersIdsList.length ; endIndex += 10) {
        futures.add(db.collection("users").where("sevauserid", whereIn: usersIdsList.sublist(startIndex, endIndex)).getDocuments());
        startIndex = endIndex;
      }
    }
    futures.add(db.collection("users").where("sevauserid", whereIn: usersIdsList.sublist(startIndex, usersIdsList.length)).getDocuments());

    var futuresResult = await Future.wait(futures);

    futuresResult.forEach((snapUser) {
      if(!snapUser.documents.isEmpty){
        snapUser.documents.forEach((docUser){
          upcomingEventsArr.forEach((OfferModel upcomingEvent) {
            if (upcomingEvent.groupOfferDataModel.signedUpMembers.contains(docUser.data['sevauserid'])) {
              uuidvar = Uuid().generateV4();
              batch.setData(
                  db.collection("users").document(docUser.documentID).collection("notifications").document(uuidvar),
                  {
                    'communityId': upcomingEvent.communityId,
                    'data': {
                      'eventName': upcomingEvent.groupOfferDataModel.classTitle,
                      'eventDate': upcomingEvent.groupOfferDataModel.startDate,
                      'offerId': upcomingEvent.id,
                    },
                    'id': uuidvar,
                    'isRead': false,
                    'senderUserId': upcomingEvent.sevaUserId,
                    'timebankId': upcomingEvent.timebankId,
                    'timestamp': DateTime.now().millisecondsSinceEpoch,
                    'type': "RecurringOfferUpdated",
                    'userId': docUser.data['sevauserid']
                  });
            }
          });
        });
      }
    });
  }

  // s6 ---------- change in projects pendingrequests, and put it all into a batch and commit them

  await batch.commit();
}

Stream<List<OfferModel>> getOfferNotificationStream({
  @required String userId,
}) async* {
  var data = Firestore.instance
      .collection('notifications')
      .document(userId)
      .collection('offerRequest')
      .snapshots();

  yield* data.transform(
    StreamTransformer<QuerySnapshot, List<OfferModel>>.fromHandlers(
      handleData: (snapshot, offerSink) {
        List<OfferModel> offerList = [];
        snapshot.documents.forEach((documentSnapshot) {
          OfferModel offer = OfferModel.fromMap(documentSnapshot.data);
          offerList.add(offer);
        });
        offerSink.add(offerList);
      },
    ),
  );
}

Stream<List<RequestModel>> getOfferRequestApprovedNotificationStream({
  @required String userId,
}) async* {
  var data = Firestore.instance
      .collection('notifications')
      .document(userId)
      .collection('offerAccepted')
      .snapshots();

  yield* data.transform(
    StreamTransformer<QuerySnapshot, List<RequestModel>>.fromHandlers(
      handleData: (snapshot, requestSink) {
        List<RequestModel> requestList = [];
        snapshot.documents.forEach((document) {
          RequestModel model = RequestModel.fromMap(document.data);
          model.id = document.documentID;
          requestList.add(model);
        });
        requestSink.add(requestList);
      },
    ),
  );
}

Future<void> deleteOfferRequestApproval({
  @required RequestModel request,
}) async {
  await Firestore.instance
      .collection('notifications')
      .document(request.sevaUserId)
      .collection('offerAccepted')
      .document(request.id)
      .delete();
}

Future<void> updateOfferWithRequest({
  @required OfferModel offer,
}) async {
  await Firestore.instance
      .collection('offers')
      .document(offer.id)
      .setData(offer.toMap(), merge: true);
}
