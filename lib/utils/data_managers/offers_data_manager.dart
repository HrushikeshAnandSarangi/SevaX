import 'dart:async';
import 'dart:developer';

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:geoflutterfire/geoflutterfire.dart';
import 'package:meta/meta.dart';
import 'package:sevaexchange/components/get_location.dart';
import 'package:sevaexchange/models/offer_model.dart';
import 'package:sevaexchange/models/request_model.dart';
import 'package:sevaexchange/repositories/firestore_keys.dart';
import 'package:sevaexchange/ui/utils/location_helper.dart';
import 'package:sevaexchange/utils/log_printer/log_printer.dart';

Geoflutterfire geoflutterfire = Geoflutterfire();

Stream<List<OfferModel>> getOffersStream(
    {String timebankId, String loggedInMemberSevaUserId}) async* {
  logger.i("offer list request started");
  // Stopwatch sw = Stopwatch();
  // sw.start();
  var query = CollectionRef.offers
      .where('timebanksPosted', arrayContains: timebankId)
      .where('assossiatedRequest', isNull: true)
      .where('softDelete', isEqualTo: false)
      .where('autoGenerated', isEqualTo: false)
      .orderBy(
        'timestamp',
        descending: true,
      );

  var data = query.snapshots();
  logger.i("fetched data");
  Coordinates coordinates = await LocationHelper.getCoordinates();

  yield* data.transform(
    StreamTransformer<QuerySnapshot, List<OfferModel>>.fromHandlers(
      handleData: (snapshot, offerSink) async {
        List<OfferModel> offerList = [];

        snapshot.docs.forEach((snapshot) {
          OfferModel model = OfferModel.fromMap(snapshot.data());
          log(model.id + '--->' + model.offerType.toString());

          model.id = snapshot.id;
          model.currentUserLocation = coordinates;

          if (model.offerType == OfferType.GROUP_OFFER && !model.groupOfferDataModel.isCanceled) {
            offerList.add(model);
          } else if (model.offerType == OfferType.INDIVIDUAL_OFFER) {
            if (model.individualOfferDataModel.timeOfferType == 'ONE_TIME' &&
                model.individualOfferDataModel.isAccepted) {
              if (model.sevaUserId == loggedInMemberSevaUserId) {
                offerList.add(model);
              } else {}
            } else {
              if ((model.type == RequestType.LENDING_OFFER &&
                  model.lendingOfferDetailsModel.lendingOfferTypeMode == "ONE_TIME" &&
                  model.individualOfferDataModel.isAccepted)) {
              } else {
                offerList.add(model);
              }
            }
          }
        });

        offerSink.add(offerList);
        // logger.i('offer loading time ${sw.elapsedMilliseconds}');
      },
    ),
  );
  // sw.stop();
}

Future<void> createOffer({@required OfferModel offerModel}) async {
  await CollectionRef.offers.doc(offerModel.id).set(offerModel.toMap());
}

Future<void> updateOffersByFields({List<String> offerIds, Map<String, dynamic> fields}) async {
  var futures = <Future>[];
  int i;
  for (i = 0; i < offerIds.length; i++) {
    futures.add(CollectionRef.offers.doc(offerIds[i]).update(fields));
  }
  await Future.wait(futures);
}

Future<List<String>> createRecurringEventsOffer({@required OfferModel offerModel}) async {
  var batch = CollectionRef.batch;

  bool lastRound = false;
  DateTime eventStartDate =
          DateTime.fromMillisecondsSinceEpoch(offerModel.groupOfferDataModel.startDate),
      eventEndDate = DateTime.fromMillisecondsSinceEpoch(offerModel.groupOfferDataModel.endDate);
  List<Map<String, dynamic>> temparr = [];
  List<String> offerIds = [];
  offerIds.add(offerModel.id);
  DocumentSnapshot projectDoc = null;

  if (offerModel.end.endType == "on") {
    //end type is on
    int occurenceCount = 2;
    var numTemp = 0;
    while (lastRound == false) {
      eventStartDate = DateTime(eventStartDate.year, eventStartDate.month, eventStartDate.day + 1,
          eventStartDate.hour, eventStartDate.minute, eventStartDate.second);
      eventEndDate = DateTime(eventEndDate.year, eventEndDate.month, eventEndDate.day + 1,
          eventEndDate.hour, eventEndDate.minute, eventEndDate.second);

      if (eventStartDate.millisecondsSinceEpoch <= offerModel.end.on && occurenceCount < 11) {
        numTemp = eventStartDate.weekday % 7;
        if (offerModel.recurringDays.contains(numTemp)) {
          OfferModel temp = offerModel;
          temp.groupOfferDataModel.startDate = eventStartDate.millisecondsSinceEpoch;
          temp.groupOfferDataModel.endDate = eventEndDate.millisecondsSinceEpoch;
          temp.timestamp = DateTime.now().millisecondsSinceEpoch;
          temp.id = temp.email +
              "*" +
              temp.timestamp.toString() +
              "*" +
              temp.groupOfferDataModel.startDate.toString();
          temp.occurenceCount = occurenceCount;
          occurenceCount++;
          temp.softDelete = false;
          temp.isRecurring = false;
          temp.autoGenerated = true;
          temparr.add(temp.toMap());
        }
      } else {
        lastRound = true;
        break;
      }
    }
  } else {
    //end type is after
    var numTemp = 0;
    int occurenceCount = 2;
    while (occurenceCount <= offerModel.end.after) {
      eventStartDate = DateTime(eventStartDate.year, eventStartDate.month, eventStartDate.day + 1,
          eventStartDate.hour, eventStartDate.minute, eventStartDate.second);
      eventEndDate = DateTime(eventEndDate.year, eventEndDate.month, eventEndDate.day + 1,
          eventEndDate.hour, eventEndDate.minute, eventEndDate.second);

      numTemp = eventStartDate.weekday % 7;
      if (offerModel.recurringDays.contains(numTemp)) {
        OfferModel temp = offerModel;
        temp.groupOfferDataModel.startDate = eventStartDate.millisecondsSinceEpoch;
        temp.groupOfferDataModel.endDate = eventEndDate.millisecondsSinceEpoch;
        temp.timestamp = DateTime.now().millisecondsSinceEpoch;
        temp.id = temp.email +
            "*" +
            temp.timestamp.toString() +
            "*" +
            temp.groupOfferDataModel.startDate.toString();
        temp.occurenceCount = occurenceCount;
        occurenceCount++;
        temp.softDelete = false;
        temp.isRecurring = false;
        temp.autoGenerated = true;
        temparr.add(temp.toMap());
      }
      if (occurenceCount > offerModel.end.after) {
        break;
      }
    }
  }

  temparr.forEach((tempobj) {
    batch.set(CollectionRef.offers.doc(tempobj['id']), tempobj);
    offerIds.add(tempobj['id']);
    log("---------   ${DateTime.fromMillisecondsSinceEpoch(tempobj['groupOfferDataModel']['startDate']).toString()} with occurence count of ${tempobj['occurenceCount']}");
  });

  await batch.commit();
  return offerIds;
}

Future<void> updateRecurrenceOffersFrontEnd({@required OfferModel updatedOfferModel}) async {
  var batch = CollectionRef.batch;
  bool lastRound = false;
  String uuidvar = "";
  OfferModel eventData, parentEvent;

  List<OfferModel> upcomingEventsArr = [], prevEventsArr = [];
  var futures = <Future>[];
  Set<String> usersIds = Set();
  DateTime eventStartDate =
          DateTime.fromMillisecondsSinceEpoch(updatedOfferModel.groupOfferDataModel.startDate),
      eventEndDate =
          DateTime.fromMillisecondsSinceEpoch(updatedOfferModel.groupOfferDataModel.endDate);

  QuerySnapshot snapEvents = await CollectionRef.offers
      .where("parent_offer_id", isEqualTo: updatedOfferModel.parent_offer_id)
      .get();

  snapEvents.docs.forEach((eventDoc) {
    eventData = OfferModel.fromMap(eventDoc.data());
    if (eventData.occurenceCount == 1) {
      parentEvent = eventData;
    } else if (eventData.occurenceCount > updatedOfferModel.occurenceCount) {
      upcomingEventsArr.add(eventData);
    } else if (eventData.occurenceCount < updatedOfferModel.occurenceCount) {
      prevEventsArr.add(eventData);
    }
  });
  // s1 ---------- create set of events with updated data

  List<Map<String, dynamic>> temparr = [];

  if (updatedOfferModel.end.endType == "on") {
    //end type is on
    int occurenceCount = updatedOfferModel.occurenceCount + 1;
    var numTemp = 0;
    while (lastRound == false) {
      eventStartDate = DateTime(eventStartDate.year, eventStartDate.month, eventStartDate.day + 1,
          eventStartDate.hour, eventStartDate.minute, eventStartDate.second);
      eventEndDate = DateTime(eventEndDate.year, eventEndDate.month, eventEndDate.day + 1,
          eventEndDate.hour, eventEndDate.minute, eventEndDate.second);
      if (eventStartDate.millisecondsSinceEpoch <= updatedOfferModel.end.on &&
          occurenceCount < 11) {
        numTemp = eventStartDate.weekday % 7;
        if (updatedOfferModel.recurringDays.contains(numTemp)) {
          OfferModel temp = updatedOfferModel;
          temp.groupOfferDataModel.startDate = eventStartDate.millisecondsSinceEpoch;
          temp.groupOfferDataModel.endDate = eventEndDate.millisecondsSinceEpoch;
          temp.timestamp = DateTime.now().millisecondsSinceEpoch;
          temp.id = temp.email +
              "*" +
              temp.timestamp.toString() +
              "*" +
              temp.groupOfferDataModel.startDate.toString();
          temp.occurenceCount = occurenceCount;
          occurenceCount++;
          temp.softDelete = false;
          temp.isRecurring = false;
          temp.autoGenerated = true;
          temparr.add(temp.toMap());
        }
      } else {
        lastRound = true;
        break;
      }
    }
  } else {
    //end type is after
    var numTemp = 0;
    int occurenceCount = updatedOfferModel.occurenceCount + 1;
    while (occurenceCount <= updatedOfferModel.end.after) {
      eventStartDate = DateTime(eventStartDate.year, eventStartDate.month, eventStartDate.day + 1,
          eventStartDate.hour, eventStartDate.minute, eventStartDate.second);
      eventEndDate = DateTime(eventEndDate.year, eventEndDate.month, eventEndDate.day + 1,
          eventEndDate.hour, eventEndDate.minute, eventEndDate.second);
      numTemp = eventStartDate.weekday % 7;
      if (updatedOfferModel.recurringDays.contains(numTemp)) {
        OfferModel temp = updatedOfferModel;
        temp.groupOfferDataModel.startDate = eventStartDate.millisecondsSinceEpoch;
        temp.groupOfferDataModel.endDate = eventEndDate.millisecondsSinceEpoch;
        temp.timestamp = DateTime.now().millisecondsSinceEpoch;
        temp.id = temp.email +
            "*" +
            temp.timestamp.toString() +
            "*" +
            temp.groupOfferDataModel.startDate.toString();
        temp.occurenceCount = occurenceCount;
        occurenceCount++;
        temp.softDelete = false;
        temp.isRecurring = false;
        temp.autoGenerated = true;
        temparr.add(temp.toMap());
      }
      if (occurenceCount > updatedOfferModel.end.after) {
        break;
      }
    }
  }

  temparr.forEach((tempobj) {
    batch.set(CollectionRef.offers.doc(tempobj['id']), tempobj);
    log("---------   ${DateTime.fromMillisecondsSinceEpoch(tempobj['groupOfferDataModel']['startDate']).toString()} with occurence count of ${tempobj['occurenceCount']}");
  });

  // s2 ---------- update parent request and previous events with end data of updated event model

  batch.update(CollectionRef.offers.doc(updatedOfferModel.parent_offer_id),
      {"end": updatedOfferModel.end.toMap(), "recurringDays": updatedOfferModel.recurringDays});

  // s3 ---------- delete old recurrences since the updated model

  if (upcomingEventsArr.length != 0) {
    upcomingEventsArr.forEach((upcomingEvent) {
      batch.delete(
          CollectionRef.offers.doc(upcomingEvent.id)); // delete old upcoming recurrence-events
    });
  }

  // s5 ---------- send notifications in case users have part of members

  upcomingEventsArr.forEach((upcomingEvent) {
    if (upcomingEvent.groupOfferDataModel.signedUpMembers.length > 0) {
      upcomingEvent.groupOfferDataModel.signedUpMembers.forEach((signedUpMemberId) {
        usersIds.add(signedUpMemberId);
      });
    }
  });
  List<String> usersIdsList = [];
  usersIdsList = usersIds.toList();
  int startIndex = 0, endIndex;

  if (usersIdsList.length > 0) {
    if (usersIdsList.length > 10) {
      for (endIndex = 10; endIndex < usersIdsList.length; endIndex += 10) {
        futures.add(CollectionRef.users
            .where("sevauserid", whereIn: usersIdsList.sublist(startIndex, endIndex))
            .get());
        startIndex = endIndex;
      }
    }
    futures.add(CollectionRef.users
        .where("sevauserid", whereIn: usersIdsList.sublist(startIndex, usersIdsList.length))
        .get());

    var futuresResult = await Future.wait(futures);

    futuresResult.forEach((snapUser) {
      if (!snapUser.documents.isEmpty) {
        snapUser.docs.forEach((docUser) {
          upcomingEventsArr.forEach((OfferModel upcomingEvent) {
            if (upcomingEvent.groupOfferDataModel.signedUpMembers
                .contains(docUser.data['sevauserid'])) {
              uuidvar = Uuid().generateV4();
              batch.set(
                  CollectionRef.users.doc(docUser.id).collection("notifications").doc(uuidvar), {
                'communityId': upcomingEvent.communityId,
                'data': {
                  'eventName': upcomingEvent.groupOfferDataModel.classTitle,
                  'eventDate': upcomingEvent.groupOfferDataModel.startDate,
                  'offerId': upcomingEvent.id,
                },
                'id': uuidvar,
                'isRead': false,
                'senderUserId': upcomingEvent.sevaUserId,
                'timebankId': upcomingEvent.timebankId,
                'timestamp': DateTime.now().millisecondsSinceEpoch,
                'type': "RecurringOfferUpdated",
                'userId': docUser.data['sevauserid']
              });
            }
          });
        });
      }
    });
  }

  // s6 ---------- change in projects pendingrequests, and put it all into a batch and commit them

  await batch.commit();
}

// Stream<List<OfferModel>> getOfferNotificationStream({
//   @required String userId,
// }) async* {
//   var data = CollectionRef.collection('notifications')
//       .doc(userId)
//       .collection('offerRequest')
//       .snapshots();

//   yield* data.transform(
//     StreamTransformer<QuerySnapshot, List<OfferModel>>.fromHandlers(
//       handleData: (snapshot, offerSink) {
//         List<OfferModel> offerList = [];
//         snapshot.docs.forEach((documentSnapshot) {
//           OfferModel offer = OfferModel.fromMap(documentSnapshot.data);
//           offerList.add(offer);
//         });
//         offerSink.add(offerList);
//       },
//     ),
//   );
// }

// Stream<List<RequestModel>> getOfferRequestApprovedNotificationStream({
//   @required String userId,
// }) async* {
//   var data = CollectionRef.collection('notifications')
//       .doc(userId)
//       .collection('offerAccepted')
//       .snapshots();

//   yield* data.transform(
//     StreamTransformer<QuerySnapshot, List<RequestModel>>.fromHandlers(
//       handleData: (snapshot, requestSink) {
//         List<RequestModel> requestList = [];
//         snapshot.docs.forEach((document) {
//           RequestModel model = RequestModel.fromMap(document.data());
//           model.id = document.id;
//           requestList.add(model);
//         });
//         requestSink.add(requestList);
//       },
//     ),
//   );
// }

// Future<void> deleteOfferRequestApproval({
//   @required RequestModel request,
// }) async {
//   await CollectionRef.collection('notifications')
//       .doc(request.sevaUserId)
//       .collection('offerAccepted')
//       .doc(request.id)
//       .delete();
// }

Future<void> updateOfferWithRequest({
  @required OfferModel offer,
}) async {
  await CollectionRef.offers.doc(offer.id).update(offer.toMap());
}

Stream<List<OfferModel>> getBookMarkedOffers(
    {@required String sevaUserId, @required String timebankid}) async* {
  var data = CollectionRef.offers
      .where(
        'individualOfferDataModel.offerAcceptors',
        arrayContains: sevaUserId,
      )
      .orderBy('timestamp', descending: true)
      .snapshots();

  yield* data.transform(
    StreamTransformer<QuerySnapshot, List<OfferModel>>.fromHandlers(
      handleData: (snapshot, offerSink) async {
        List<OfferModel> offerList = [];

        snapshot.docs.forEach((snapshot) {
          OfferModel model = OfferModel.fromMap(snapshot.data());
          model.id = snapshot.id;

          if (model.timebanksPosted != null && model.timebanksPosted.contains(timebankid)) {
            offerList.add(model);
          }
        });
        offerSink.add(offerList);
      },
    ),
  );
}
