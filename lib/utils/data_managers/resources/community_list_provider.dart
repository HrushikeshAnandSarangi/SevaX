import 'dart:async';

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:sevaexchange/models/models.dart';
import 'package:sevaexchange/new_baseline/models/community_model.dart';
import 'package:sevaexchange/utils/data_managers/blocs/communitylist_bloc.dart';

class RequestApiProvider {
  Future<List<UserModel>> getUserFromRequest(String requestID) async {
    List<UserModel> usersDataList = [];

    var query = Firestore.instance
        .collection('users')
        .where("invitedRequests", arrayContains: requestID);

    QuerySnapshot querySnapshot = await query.getDocuments();

    querySnapshot.documents.forEach((documentSnapshot) {
      UserModel model =
          UserModel.fromMap(documentSnapshot.data, 'community_list_provider');
      usersDataList.add(model);
    });
    return usersDataList;
  }

  Future<List<RequestModel>> getRequestListFuture(String timebankId) async {
    List<RequestModel> requestList = [];
    var query = timebankId == null || timebankId == 'All'
        ? Firestore.instance
            .collection('requests')
            .where('accepted', isEqualTo: false)
            .orderBy("posttimestamp", descending: true)
        : Firestore.instance
            .collection('requests')
            .where('timebankId', isEqualTo: timebankId)
            .where('accepted', isEqualTo: false)
            .orderBy("posttimestamp", descending: true);

    QuerySnapshot querySnapshot = await query.getDocuments();
    querySnapshot.documents.forEach((documentSnapshot) {
      RequestModel model = RequestModel.fromMap(documentSnapshot.data);
      model.id = documentSnapshot.documentID;
      if (model.approvedUsers.length <= model.numberOfApprovals) {
        requestList.add(model);
      }
    });
    return requestList;
  }

  Future<List<RequestModel>> getProjectCompletedList({String projectId}) async {
    List<RequestModel> requestList = [];
    var query = Firestore.instance
        .collection('requests')
        .where('accepted', isEqualTo: true)
        .where('projectId', isEqualTo: projectId);

    QuerySnapshot querySnapshot = await query.getDocuments();
    querySnapshot.documents.forEach((documentSnapshot) {
      RequestModel model = RequestModel.fromMap(documentSnapshot.data);
      model.id = documentSnapshot.documentID;
      requestList.add(model);
    });
    return requestList;
  }

  Future<List<RequestModel>> getProjectPendingList({String projectId}) async {
    List<RequestModel> requestList = [];
    var query = Firestore.instance
        .collection('requests')
        .where('accepted', isEqualTo: false)
        .where('projectId', isEqualTo: projectId);

    QuerySnapshot querySnapshot = await query.getDocuments();
    querySnapshot.documents.forEach((documentSnapshot) {
      RequestModel model = RequestModel.fromMap(documentSnapshot.data);
      model.id = documentSnapshot.documentID;
      requestList.add(model);
    });
    return requestList;
  }

  Stream<List<RequestModel>> getRequestListStream({String timebankId}) async* {
    var query = timebankId == null || timebankId == 'All'
        ? Firestore.instance
            .collection('requests')
            .where('accepted', isEqualTo: false)
            .where('autoGenerated', isEqualTo: false)
            .where('softDelete', isEqualTo: false)
        : Firestore.instance
            .collection('requests')
            .where('timebankId', isEqualTo: timebankId)
            .where('softDelete', isEqualTo: false)
            .where('autoGenerated', isEqualTo: false)
            .where('accepted', isEqualTo: false);

    var data = query.snapshots();

    yield* data.transform(
      StreamTransformer<QuerySnapshot, List<RequestModel>>.fromHandlers(
        handleData: (snapshot, requestSink) {
          List<RequestModel> requestList = [];
          snapshot.documents.forEach(
            (documentSnapshot) {
              RequestModel model = RequestModel.fromMap(documentSnapshot.data);
              model.id = documentSnapshot.documentID;
              if (model.approvedUsers.length <= model.numberOfApprovals &&
                  model.requestEnd > DateTime.now().millisecondsSinceEpoch) {
                requestList.add(model);
              }
            },
          );
          requestSink.add(requestList);
        },
      ),
    );
  }

  Future<void> updateInvitedUsersForRequest(
      String requestID, String sevaUserId) async {
    List<String> list = List();
    list.add(sevaUserId);

    await Firestore.instance
        .collection('requests')
        .document(requestID)
        .updateData({
      'invitedUsers': FieldValue.arrayUnion([sevaUserId])
    }).then((onValue) {
      return "Updated invitedUsers";
    }).catchError((onError) {
      return "Error Updating invitedUsers";
    });
  }
}

class CommunityApiProvider {
//  Future<CategoryListModel> fetchCategoryList() async {
//    Response response;
//    if(_apiKey != 'api-key') {
//       response = await client.get("$_baseUrl/popular?api_key=$_apiKey");
//    }else{
//      throw Exception('Please add your API key');
//    }
//    if (response.statusCode == 200) {
//      // If the call to the server was successful, parse the JSON
//      return CategoryListModel.fromJson(json.decode(response.body));
//    } else {
//      // If that call was not successful, throw an error.
//      throw Exception('Failed to load post');
//    }
//  }

  Future<bool> isCommunityFound(String enteredName) async {
    //ommunityBloc.fetchCommunities(enteredName);
    CommunityListModel communities = CommunityListModel();
    var communitiesFound =
        await searchCommunityByName(enteredName, communities);
    if (communitiesFound == null ||
        communitiesFound.communities == null ||
        communitiesFound.communities.length == 0) {
      return false;
    } else {
      return true;
    }
  }

  Future<CommunityListModel> searchCommunityByName(
      String name, CommunityListModel communities) async {
    communities.removeall();
    if (name.isNotEmpty && name.length > 4) {
      await Firestore.instance
          .collection('communities')
          .where('name', isEqualTo: name)
          .getDocuments()
          .then((QuerySnapshot querySnapshot) {
        querySnapshot.documents.forEach((DocumentSnapshot documentSnapshot) {
          var community = CommunityModel(documentSnapshot.data);

          communities.add(community);
        });
      });
    }
    return communities;
  }

  Future<TimebankListModel> searchTimebankSiblingsByParentId(
      String id, TimebankListModel timebanks) async {
    timebanks.removeall();
    if (id.isNotEmpty) {
      await Firestore.instance
          .collection('timebanknew')
          .where('associatedParentTimebankId', isEqualTo: id)
          .getDocuments()
          .then((QuerySnapshot querySnapshot) {
        querySnapshot.documents.forEach((DocumentSnapshot documentSnapshot) {
          var timebank = TimebankModel(documentSnapshot.data);
          timebanks.add(timebank);
        });
      });
    }
    return timebanks;
  }

  Future<void> updateCommunityWithUserId(communityId, userId) async {
    var response = await Firestore.instance
        .collection("communities")
        .document(communityId)
        .updateData({
      'members': FieldValue.arrayUnion([userId])
    });
    return response;
  }

  Future<void> createCommunityByName(CommunityModel community) async {
    await Firestore.instance
        .collection('communities')
        .document(community.id)
        .setData(community.toMap());
  }

  Future<void> updateUserWithTimeBankIdCommunityId(
      UserModel user, timebankId, communityId) async {
    // if user is already part of community
    var found = false;
    if (user.communities != null) {
      for (var i = 0; i < user.communities.length; i++) {
        if (user.communities[i] == communityId) {
          found = true;
        }
      }
    } else {
      user.communities = List();
    }
    if (!found) {
      user.communities = [
        ...user.communities,
        ...[communityId]
      ];
    }
    found = false;
    if (user.membershipTimebanks != null) {
      for (var i = 0; i < user.membershipTimebanks.length; i++) {
        if (user.membershipTimebanks[i] == timebankId) {
          found = true;
        }
      }
    } else {
      user.membershipTimebanks = [];
    }
    if (!found) {
      user.membershipTimebanks = [
        ...user.membershipTimebanks,
        ...[timebankId]
      ];
    }
    await Firestore.instance
        .collection('users')
        .document(user.email)
        .updateData({
          'membershipTimebanks': user.membershipTimebanks,
          'communities': user.communities,
          'currentCommunity': communityId
        })
        .then((onValue) {})
        .catchError((onError) {});
  }
}
