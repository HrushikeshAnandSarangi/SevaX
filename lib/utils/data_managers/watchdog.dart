import 'dart:developer';

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/material.dart';
import 'package:sevaexchange/models/request_model.dart';
import 'package:sevaexchange/new_baseline/models/project_model.dart';
import 'package:sevaexchange/utils/utils.dart';

class WatchDog {
  Future<List<String>> createRecurringEvents({
    @required ProjectModel projectModel,
    @required String communityId,
    @required String timebankId,
  }) async {
    var batch = Firestore.instance.batch();
    var db = Firestore.instance;
    DateTime eventStartDate =
        DateTime.fromMillisecondsSinceEpoch(projectModel.startTime);
    DateTime eventEndDate =
        DateTime.fromMillisecondsSinceEpoch(projectModel.endTime);

    bool lastRound = false;
    List<Map<String, dynamic>> temparr = [];
    List<String> eventsIdsArr = [];
    batch.setData(db.collection("projects").document(projectModel.id),
        projectModel.toMap());

    if (projectModel.end.endType == "on") {
      //end type is on
      int occurenceCount = 2;
      var numTemp = 0;
      while (lastRound == false) {
        eventStartDate = DateTime(
            eventStartDate.year,
            eventStartDate.month,
            eventStartDate.day + 1,
            eventStartDate.hour,
            eventStartDate.minute,
            eventStartDate.second);
        eventEndDate = DateTime(
            eventEndDate.year,
            eventEndDate.month,
            eventEndDate.day + 1,
            eventEndDate.hour,
            eventEndDate.minute,
            eventEndDate.second);

        if (eventStartDate.millisecondsSinceEpoch <= projectModel.end.on &&
            occurenceCount < 11) {
          numTemp = eventStartDate.weekday % 7;
          if (projectModel.recurringDays.contains(numTemp)) {
            ProjectModel temp = projectModel;
            temp.startTime = eventStartDate.millisecondsSinceEpoch;
            temp.endTime = eventEndDate.millisecondsSinceEpoch;
            temp.createdAt = DateTime.now().millisecondsSinceEpoch;
            temp.id = Utils.getUuid();
            temp.occurenceCount = occurenceCount;
            occurenceCount++;
            temp.softDelete = false;
            temp.isRecurring = false;
            temp.autoGenerated = true;
            temparr.add(temp.toMap());
          }
        } else {
          lastRound = true;
          break;
        }
      }
    } else {
      //end type is after
      var numTemp = 0;
      int occurenceCount = 2;
      while (occurenceCount <= projectModel.end.after) {
        eventStartDate = DateTime(
            eventStartDate.year,
            eventStartDate.month,
            eventStartDate.day + 1,
            eventStartDate.hour,
            eventStartDate.minute,
            eventStartDate.second);
        eventEndDate = DateTime(
            eventEndDate.year,
            eventEndDate.month,
            eventEndDate.day + 1,
            eventEndDate.hour,
            eventEndDate.minute,
            eventEndDate.second);

        numTemp = eventStartDate.weekday % 7;
        if (projectModel.recurringDays.contains(numTemp)) {
          ProjectModel temp = projectModel;
          temp.startTime = eventStartDate.millisecondsSinceEpoch;
          temp.endTime = eventEndDate.millisecondsSinceEpoch;
          temp.createdAt = DateTime.now().millisecondsSinceEpoch;
          temp.id = Utils.getUuid();
          temp.occurenceCount = occurenceCount;
          occurenceCount++;
          temp.softDelete = false;
          temp.isRecurring = false;
          temp.autoGenerated = true;
          temparr.add(temp.toMap());
        }
        if (occurenceCount > projectModel.end.after) {
          break;
        }
      }
    }

    eventsIdsArr.add(projectModel.id);
    temparr.forEach((tempobj) {
      batch.setData(db.collection("projects").document(tempobj['id']), tempobj);
      eventsIdsArr.add(tempobj['id']);
    });

    await batch.commit();
    return eventsIdsArr;
  }
}
